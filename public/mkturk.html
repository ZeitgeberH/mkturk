<!doctype html>

<head>
<meta name="mobile-web-app-capable" content="yes"> <!-- full screen https://developer.chrome.com/multidevice/android/installtohomescreen -->

<meta name="viewport" content="width=device-width, user-scalable=no"> <!-- do not allow window rescaling.  To avoid window rescaling in portrait mode, added with=device-width from http://stackoverflow.com/questions/22771523/ipad-w-retina-safari-reported-dimensions-in-landscape-make-no-sense -->

<link rel="manifest" href="mkturkmanifest.json">
<link rel="icon" href="mkturklogo48.png">

<script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js"></script>
<script src="utils.js"></script>

<!-- <script src="mkturkdropbox.js" type="text/javascript"></script>
<script src="mkturkautomator.js" type="text/javascript"></script>
<script src="mkturkble.js" type="text/javascript"></script> -->

<script>
//================== LOAD STATUS DISPLAY ==================//
function writeTextonBlankCanvas(textstr,x,y){
	var blank_canvasobj=document.getElementById("canvas"+canvas.blank)
	var visible_ctxt = blank_canvasobj.getContext('2d')
	visible_ctxt.textBaseline = "hanging"
	visible_ctxt.fillStyle = "white"
	visible_ctxt.font = "18px Verdana"
	visible_ctxt.fillText(textstr,x,y)
}
function updateStatusText(){
	var textobj = document.getElementById("headsuptext");
	textobj.innerHTML = ble.statustext
	// updateHeadsUpDisplay()
}
function updateHeadsUpDisplay(){
	var textobj = document.getElementById("headsuptext");
	// Overall performance
	var ncorrect = 0;
	for (var i=0; i<=trial.correctItem.length-1; i++){
  		if (trial.correctItem[i] == trial.response[i]){
  			ncorrect++;
  		}
	}
	var pctcorrect = Math.round(100 * ncorrect / trial.response.length);
	// Task type
	var task1 = "";
	var task2 = "";
	if (trial.rewardStage == 0){
		task1 = "Fixation Task";
	}
	else if (trial.rewardStage == 1){
		task1 = "Match to Sample Task var" + trial.imageFolderSample;
		task2 = trial.sampleON + "ms, " + trial.nway + "-way, " + trial.objectlist.length + "-obj";
	}
	if (canvas.headsupfraction > 0){
		textobj.innerHTML =
			trial.subjid +
			": <font color=green><b>" + pctcorrect + "%</b></font> " + "(" + ncorrect + " of " + trial.response.length +")" + 
			"<br>" + "Estimated Reward: <font color=green><b>" + Math.round(trial.rewardper1000*ncorrect/1000) + "mL</b></font> (" + Math.round(trial.rewardper1000) + " per 1000)" + "<br>" +
			task1 + "<br>" + task2 + "<br> " + "<br>" + 
			
			"<font color=blue><b>" + ble.statustext + "<br></font>";
	}
	else if (canvas.headsupfraction == 0){
		textobj.innerHTML = ble.statustext
	}
}
function updateHeadsUpDisplayAutomator(){
	var textobj = document.getElementById("headsuptextautomator");
	if (canvas.headsupfraction > 0){
		textobj.innerHTML =
			"Automator: " + 
			"<font color=red><b>" + trial.automator + " " + 
				trialhistory.trainingstagename + "</b></font> " + 
			" (stage " + trialhistory.trainingstage[trialhistory.current-1] + ")"+ "<br>" +
			"Running Avg: " + 
			"<font color=green><b>" + Math.round(trialhistory.pctcorrect) + "%, " + trialhistory.ntrials_running + " trials</b></font> " + 
			"(min: " + trialhistory.minpctcorrect + 
				"%, " + trialhistory.mintrials + " trials)" + "<br>" +  
			"Total: " + [trialhistory.correct.length - trialhistory.startingindex] + " trials"
	}
	else if (canvas.headsupfraction == 0){
		textobj.innerHTML = ""
	}
}
//================== (end) STATUS DISPLAY ==================//
//================== PROMISE STATES ==================//
	// Promise: Select Subject
	function subjidPromise(){
		var resolveFunc
		var errFunc
		p = new Promise(function(resolve,reject){
			resolveFunc = resolve;
			errFunc = reject;
		}).then(function(resolveval){console.log('User selected ' + resolveval)});
		function *waitforclickGenerator(){
			var imclicked =[-1];
			while (true){
				imclicked = yield imclicked;
				resolveFunc(imclicked);
			}
		}
		waitforClick = waitforclickGenerator(); // start async function
		waitforClick.next(); //move out of default state
		return p;
	}
	function subjectlist_listener(event){
		console.log("subject selected");
		trial.subjid = subjectlist[this.value];
		subjectdialog.close();
		waitforClick.next(1);
		return
	}
	// Promise: Edit Parameters Text
	function editParamsPromise(){
		var resolveFunc
		var errFunc
		p = new Promise(function(resolve,reject){
			resolveFunc = resolve;
			errFunc = reject;
		}).then(function(resolveval){console.log('User is done editing params')});
		function *waitforclickGenerator(){
			var imclicked =[-1];
			while (true){
				imclicked = yield imclicked;
				resolveFunc(imclicked);
			}
		}
		waitforClick = waitforclickGenerator(); // start async function
		waitforClick.next(); //move out of default state
		return p;
	}
	function doneEditing_listener(event){
		console.log("Done editing params")
		waitforClick.next(1);
		return
	}
	function headsuptext_listener(event){
		trial.need2writeParameters = 1
		return
	}
	function doneTesting_listener(event){
		console.log("User is done testing. Start saving data");
		trial.savedata=1
		trial.purge=1
		renderBlank() //re-render gray screen without display elements
		document.querySelector("button[name=doneTesting]").style.display = "none"
		return
	}
	// Promise: fixation
	function fixationPromise(){
		var resolveFunc
		var errFunc
		p = new Promise(function(resolve,reject){
			resolveFunc = resolve;
			errFunc = reject;
		}).then(function(resolveval){
			//console.log('Fixation Promise resolved' + resolveval)
		});
		function *waitforclickGenerator(){
			var imclicked =[-1];
			while (true){
				imclicked = yield imclicked;
				console.log('moved generator forward')
				resolveFunc(imclicked);
			}
		}
		waitforClick = waitforclickGenerator(); // start async function
		waitforClick.next(); //move out of default state
		//Start timer
		movefixationTimer = setTimeout(function(){trial.brokeFixation=1; clearTimeout(fixationTimer); waitforClick.next(1); },trial.fixationinterval);
		return p;
	}
	// Promise: response
	function responsePromise(){
		var resolveFunc
		var errFunc
		p = new Promise(function(resolve,reject){
			resolveFunc = resolve;
			errFunc = reject;
		}).then(function(resolveval){console.log('User clicked ' + resolveval)});
		function *waitforclickGenerator(){
			var imclicked =[-1];
			while (true){
				imclicked = yield imclicked;
				resolveFunc(imclicked);
			}
		}
		trial.waitingforResponse = 1;
		waitforClick = waitforclickGenerator(); // start async function
		waitforClick.next(); //move out of default state
		return p;
	}
	//Asynch: play sound
	function playSound(idx){
		audiocontext.resume()
		var source = audiocontext.createBufferSource(); // creates a sound source
		source.buffer = sounds.buffer[idx];                    // tell the source which sound to play
		if (idx==0){
			gainNode.gain.value=0.15; //set boost pedal to 15% volume
		}
		else if (idx==2 | idx==3){
			gainNode.gain.value=0.05; //set boost pedal to 5% volume
		}
		source.connect(gainNode);
		// gainNode.connect(audiocontext.destination); //Connect boost pedal to output
		// source.connect(audiocontext.destination);       // connect the source to the context's destination (the speakers)
		source.start(0);                        // play the source now
	}
	// Promise: dispense reward (through audio control)
	function dispenseReward(){
		return new Promise(function(resolve,reject){
			audiocontext.resume()
			var oscillator = audiocontext.createOscillator();
			gainNode.gain.value=1;
			if (env.pump == 1){
				oscillator.type='square'; //Square wave
				oscillator.frequency.value=25; //frequency in hertz				
			} //peristaltic (adafruit)
			else if (env.pump==2){
				oscillator.type='square'; //Square wave
				oscillator.frequency.value=0.1; //frequency in hertz
			} //submersible (TCS)
			else if (env.pump==3){
				oscillator.type='square'; //Square wave
				oscillator.frequency.value=10; //frequency in hertz		
			} //diaphragm (TCS)
			else if (env.pump==4){
				oscillator.type='square'; //Square wave
				oscillator.frequency.value=0.1; //frequency in hertz				
			} //piezoelectric (takasago)
			else if (env.pump==5){
				oscillator.type='square';
				oscillator.frequency.value=0.1;
			} //diaphragm new (TCS)
			else if (env.pump==6){
				oscillator.type='square'; //Square wave
				oscillator.frequency.value=0.1; //frequency in hertz				
			} //piezoelectric 7ml/min (takasago)
			// oscillator.connect(audiocontext.destination); //Connect sound to output
			// //var gainNode = audiocontext.createGainNode(); //Create boost pedal
			// //gainNode.gain.value=0.3; //set boost pedal to 30% volume
			oscillator.connect(gainNode);
			// //gainNode.connect(audiocontext.destination); //Connect boost pedal to output
			// // oscillator.onended=function(){
			// // 	console.log('done with reward pulse');
			// // 	resolve(1);
			// // }
			var currentTime=audiocontext.currentTime;


			oscillator.start(currentTime);
			oscillator.stop(currentTime + trial.reward);
			setTimeout(function(){console.log('sound done'); resolve(1);},trial.reward*1000);
		}).then();
	}
	// Promise: punish time-out
	function dispensePunish(){
		return new Promise(function(resolve,reject){
			setTimeout(function(){resolve(1);},trial.punish); //milliseconds
		}).then();
	}
//================== (end) PROMISE STATES ==================//
//================== MOUSE & TOUCH EVENTS ==================//
	function mousedown_listener(event){
		if(typeof event === 'undefined'){
			console.log('no click, loading images, initializing response promise');
			return
		};
		var x = event.clientX
		var y = event.clientY
		if (y < canvas.offsettop){
			//clicked on headsup display
			if (videoobj.style.zIndex != 100){
				if (trial.takephoto == 0){
					videoobj.play();
				}
				videoobj.style.zIndex = 100;
			}
			else if (videoobj.style.zIndex != 0){
				if (trial.takephoto == 0){
					videoobj.pause();
				}
				videoobj.style.zIndex = 0;
			}
		}
		if (trial.waitingforFixation > 0 && trial.fixationimagepresent == 1){
			//determine if clicked on fixation dot
			if ( x >= boundingBoxesFixation.x[0][0] && x <= boundingBoxesFixation.x[0][1] &&
				 y >= boundingBoxesFixation.y[0][0] && y <= boundingBoxesFixation.y[0][1]){
				trial.brokeFixation = 0;
				trial.xytfixation[trial.current]=[x,y,Math.round(performance.now())];
				trial.allxytfixation[trial.current][trial.fixedratio - trial.waitingforFixation] = 
				[x,y,Math.round(performance.now())]
				//Start timer
				fixationTimer = setTimeout(function(){ trial.waitingforFixation-- ;clearTimeout(movefixationTimer); waitforClick.next(1);},trial.fixationdur);
			} //if clicked fixation
			else{
			}
		}
		if (trial.waitingforResponse == 1){
			//determine if clicked in test box
			for (var q=0; q<=boundingBoxesTest.x.length-1; q++){
				if (x >= boundingBoxesTest.x[q][0] && x <= boundingBoxesTest.x[q][1] &&
					y >= boundingBoxesTest.y[q][0] && y <= boundingBoxesTest.y[q][1]){
					trial.response[trial.current]=q;
					trial.xytresponse[trial.current]=[x,y,Math.round(performance.now())];
					waitforClick.next(q);
					return
				}
			}
		}
	}
	function mousemove_listener(event){
		if (trial.waitingforFixation > 0 && trial.brokeFixation==0){
			var x = event.clientX
			var y = event.clientY

			if ( x >= boundingBoxesFixation.x[0][0] && x <= boundingBoxesFixation.x[0][1] &&
				 y >= boundingBoxesFixation.y[0][0] && y <= boundingBoxesFixation.y[0][1]){
				//holding fixation
			}
			else{
				// moved from fixation dot, cancel fixation timers
				trial.brokeFixation = 1;
				clearTimeout(fixationTimer);
			}
		}
	}
	function mouseup_listener(event){
		if (trial.waitingforFixation > 0 && trial.brokeFixation == 0){
			// broke touch with fixation dot too early, cancel fixation timers
			trial.brokeFixation = 1;
			clearTimeout(fixationTimer);
		}
	}
	function touchstart_listener(event){
		event.preventDefault(); //prevents additional downstream call of click listener
		if(typeof event === 'undefined'){
			console.log('no click, loading images, initializing responsepromise');
			return
		};
		var x = event.targetTouches[0].pageX;
		var y = event.targetTouches[0].pageY;
		if (y < canvas.offsettop){
			//clicked on headsup display
			if (videoobj.style.zIndex != 100){
				if (trial.takephoto == 0){
					videoobj.play();
				}
				videoobj.style.zIndex = 100;
			}
			else if (videoobj.style.zIndex != 0){
				if (trial.takephoto == 0){
					videoobj.pause();
				}
				videoobj.style.zIndex = 0;
			}
		}
		if (trial.waitingforFixation > 0 && trial.fixationimagepresent){
			//determine if clicked on fixation dot
			if ( x >= boundingBoxesFixation.x[0][0] && x <= boundingBoxesFixation.x[0][1] &&
				 y >= boundingBoxesFixation.y[0][0] && y <= boundingBoxesFixation.y[0][1]){
				trial.brokeFixation = 0;
				trial.xytfixation[trial.current]=[x,y,Math.round(performance.now())];
				trial.allxytfixation[trial.current][trial.fixedratio - trial.waitingforFixation] = 
				[x,y,Math.round(performance.now())]
				//Start timer
				fixationTimer = setTimeout(function(){console.log('started fixation timer');trial.waitingforFixation-- ;clearTimeout(movefixationTimer); waitforClick.next(1);},trial.fixationdur);
			} //if clicked fixation
			else{
				if (trial.rewardStage == 0){
					console.log('clicked outside fixation');
					trial.xytfixation[trial.current]=[x,y,Math.round(performance.now())];
					trial.allxytfixation[trial.current][trial.fixedratio - trial.waitingforFixation] = 
					[x,y,Math.round(performance.now())]
					trial.waitingforFixation = 0;
					trial.brokeFixation = 1;
					clearTimeout(movefixationTimer);
					clearTimeout(fixationTimer);
					waitforClick.next(0);
				} //advance to punish for clicking outside fixation
			}
		}
		if (trial.waitingforResponse == 1){
			//determine if clicked in test box
			for (var q=0; q<=boundingBoxesTest.x.length-1; q++){
				if (x >= boundingBoxesTest.x[q][0] && x <= boundingBoxesTest.x[q][1] &&
					y >= boundingBoxesTest.y[q][0] && y <= boundingBoxesTest.y[q][1]){
					trial.response[trial.current]=q;
					trial.xytresponse[trial.current]=[x,y,Math.round(performance.now())];
					waitforClick.next(q);
					return
				}
			}
		}
	}
	function touchmove_listener(event){
		if (trial.waitingforFixation > 0 && trial.brokeFixation==0){
			var x = event.targetTouches[0].pageX;
			var y = event.targetTouches[0].pageY;

			if ( x >= boundingBoxesFixation.x[0][0] && x <= boundingBoxesFixation.x[0][1] &&
				 y >= boundingBoxesFixation.y[0][0] && y <= boundingBoxesFixation.y[0][1]){
				//holding fixation
			}
			else{
				// moved from fixation dot, cancel fixation timers
				trial.brokeFixation = 1;
				console.log('was fixating but moved out');
				clearTimeout(fixationTimer);
			}
		}
		else if (trial.waitingforFixation > 0 && trial.brokeFixation==1){
			//check if moved back into fixation
			var x = event.targetTouches[0].pageX;
			var y = event.targetTouches[0].pageY;

			if ( x >= boundingBoxesFixation.x[0][0] && x <= boundingBoxesFixation.x[0][1] &&
				 y >= boundingBoxesFixation.y[0][0] && y <= boundingBoxesFixation.y[0][1]){

				//gained fixation
				trial.brokeFixation = 0;
				touchstart_listener(event);
			}
		}
		//Allows dragging into response box
		if (trial.waitingforResponse == 1){
			var x = event.targetTouches[0].pageX;
			var y = event.targetTouches[0].pageY;
			//determine if moved into a test box
			for (var q=0; q<=boundingBoxesTest.x.length-1; q++){
				if (x >= boundingBoxesTest.x[q][0] && x <= boundingBoxesTest.x[q][1] &&
					y >= boundingBoxesTest.y[q][0] && y <= boundingBoxesTest.y[q][1]){
					trial.response[trial.current]=q;
					trial.xytresponse[trial.current]=[x,y,Math.round(performance.now())];
					waitforClick.next(q);
					return
				}
			}
		}
	}
	function touchend_listener(event){
		if (trial.waitingforFixation > 0 && trial.brokeFixation == 0){
			// broke touch with fixation dot too early, cancel fixation timers
			trial.brokeFixation = 1;
			console.log('was fixating but lifted finger');
			clearTimeout(fixationTimer);
		}
	}
//================== (end) MOUSE & TOUCH EVENTS ==================//
	function getTest(nway){
		//draw category then draw images from that category
		// randomly choose an image with that category (could also do a prototype)
		// Generate cat list from sample images
		var objectlist=[];
		for (var i=0; i<=imagesSample.serial.length-1; i++){
			if (objectlist.indexOf(imagesSample.obj[i]) == -1 && imagesSample.obj[i] != imagesSample.obj[trial.sample[trial.current]]){
				objectlist[objectlist.length]=imagesSample.obj[i]; //add category
			}//if
		}//for
		// Shuffle wrt categories
		if (objectlist.length > 1){
			shuffleArray(objectlist);
		}
		//Take the first nway-1 categories
		var testArrayObj=[];
		for (var i=0; i<=nway-2; i++){
			testArrayObj[i]=objectlist[i];
		}
		//Insert sample object at end position
		testArrayObj[nway-1]=imagesSample.obj[trial.sample[trial.current]];
		// Shuffle wrt array position
		var shuffleind=[];
		shuffleind[0]=nway;
		shuffleArray(shuffleind);
		var testArrayObj_shuffleItems=[];
		var correctItem = shuffleind[shuffleind.length-1];
		for (var i=0; i<=nway-1; i++){
			testArrayObj_shuffleItems[shuffleind[i]] = testArrayObj[i];
		}
		// Shuffle wrt images in a category
		var testArray=[];
		objshuffled = testArrayObj_shuffleItems;
		for (var i=0; i<=nway-1; i++){
			// Generate image list
			var imlist=[];
			for (var j=0; j<=imagesTest.serial.length-1; j++){
				if (imagesTest.obj[j] == objshuffled[i]){
					imlist[imlist.length]=j;
				}
			}
			if (imlist.length > 1){
				shuffleArray(imlist);
			}
			testArray[i]=imlist[0];
		}
		return {
				correctItem: correctItem,
				testArray: testArray
			};
	}
function setReward(){
	var m = 0;
	var b = 0;
	if (env.pump == 1){
		// m = 1.13; b = 15.04;
		m = 0.99; b = 14.78;
	} //peristaltic (adafruit)
	else if (env.pump == 2){
		// m = 3.20; b = -15.47;
		m = 1.40; b = -58.77;
	} //submersible (tcs)
	else if (env.pump == 3){
		// m = 0.80; b = -3.00;
		m=0.91; b = -15;
	} //diaphragm (tcs)
	else if (env.pump == 4){
		m = 0.0531; b=-1.2594;
	} //piezoelectric (takasago)
	else if (env.pump == 5){
		m = 2.4463; b=53.6418;
	} //new diaphragm (tcs)
	else if (env.pump == 6){
		if (env.liquid==1 || env.liquid==3){
			m=0.1251; b=-0.0833; //1=water 2=water-condensed milk 3=marshmallow slurry (4/30mL)
		}
		else if (env.liquid==2){
			m=0.0550; b=0.6951; //water-condensed milk (50/50)
		}
	} //piezoelectric 7mL/min (takasago)
	trial.reward = (trial.rewardper1000 - b)/m/1000;
}
</script>
</head>

<!-- ************* BODY *************** -->
<body bgcolor=#7F7F7F>
<div id="canvasdiv" style="position:relative; width:100vw; height:100vh">
	<button name="connectble" style="visibility:hidden; position: absolute; top: 45%; left: 50%; height: 25px; width: 200px; border-radius: 20px">Connect to Bluetooth</button>
	<button name="noble" style="visibility:hidden; position: absolute; top: 55%; left: 50%; height: 25px; width: 100px; border-radius: 20px">No Bluetooth</button>

	<p id="headsuptext" style="z-index:99; position: absolute; left: 1px; top: 1px; height: 40%; width: 60%; font-size: 20px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;"></p>

	<p id="headsuptextautomator" style="z-index:99; position: absolute; left: 500px; top: 1px; height: 40%; width: 60%; font-size: 20px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;"></p>

	<button name="doneEditing" style="visibility:hidden; position: absolute; top: 45%; left: 70%; height: 25px; width: 100px; border-radius: 20px">Done Editing</button>

	<button name="doneTesting" style="visibility:hidden; position: absolute; top: 55%; left: 70%; height: 50px; width: 125px; border-radius: 20px; z-index:101">Done Testing</button>

	<canvas id="canvasheadsup" width="0" height="0" src="" style="z-index:98; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas0" width="0" height="0" src="" style="z-index:99; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas1" width="0" height="0" src="" style="z-index:1; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas2" width="0" height="0" src="" style="z-index:2; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas3" width="0" height="0" src="" style="z-index:3; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas4" width="0" height="0" src="" style="z-index:4; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas5" width="0" height="0" src="" style="z-index:5; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas6" width="0" height="0" src="" style="z-index:6; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas7" width="0" height="0" src="" style="z-index:7; position: absolute; left: 0px; top: 0px;"> </canvas>

	<video id="video" style="z-index:0; position: absolute; right: 0px; top: 0px;"></video>
	<canvas id="canvascapture" width="0" height="0" src="" style="z-index:0; position: absolute; left: 0px; top: 0px;"> </canvas>
</div>
<dialog id="subjid_dialog">
  <p>Subject ID</p>
 
   <!--Pull down menu that will hold file list-->
  <select id="subjid_list">
  	<option value="-1">--</option>
  </select>
</dialog>

<script>
//================== INITIALIZE VARIABLES ==================//
// Variables (general)
	var subjectlist = ["Test","Zico","Waffles","Setta","Sausage","Picasso","Pablo","Oleo","Nano","Manto","Magneto","Crypto","Bento"];
	var subjectdialog = document.getElementById("subjid_dialog");
	var subjectlistobj = document.getElementById("subjid_list");
	//populate list
	for (var q=subjectlist.length-1; q>=0; q--){
		// add menu option
		var opt = document.createElement('option');
		opt.value = q;
		opt.innerHTML = subjectlist[q];
		subjectlistobj.appendChild(opt);
	}
	subjectlistobj.addEventListener("change",subjectlist_listener,false);
	var paramfile={
		dir: "/MonkeyTurk/parameterfiles/",
		name: null,
		text: null,
		data: null,
		ver: null,
		date: null,
		datahasChanged: false,
		filehasChanged: false,
	}
	var canvas = {
		blank: 0,
		sample: 1,
		test: 2,
		touchfix: 3,
		eyefix: 4,
		reward: 5,
		photoreward: 6,
		punish: 7,
		front: 0,
		sequenceblank: [0,0],
		tsequenceblank: [0,17],
		sequencepre: [0,3],
		tsequencepre: [0,300],
		sequence: [0,1,0,2], //0=gray 1=sample 2=test 3=touchfix 4=reward 5=punish
		tsequence: [0,100,100+100,100+100+100], //timing between frames
		sequencepost: [0,5,6],
		tsequencepost: [0,25,600],
		buffered: 0,
		headsupfraction: 1/3,
		offsetleft: 0,
		offsettop: 0,
	};
	var imagesSample = {
		folder: "/MonkeyTurk/obj25/imagepacks/imp",
		packsz: 10,
		serial: [],
		obj: [],
		packpointer: [],
		packserial: [],
		packpos: [],
		pixLR: [],
		scale: 1,
	}; //filenames will be placed in images[idx].src
	var imagesTest = {
		folder: "/MonkeyTurk/obj25/imagepacks/imp",
		packsz: 10,
		serial: [],
		obj: [],
		packpointer: [],
		packserial: [],
		packpos: [],
		pixLR: [],
		scale: 1,
	}; //filenames will be placed in imagesProto[idx].src
	var imagesSampleOriginal = {
		folder: "/MonkeyTurk/obj25/imagepacks/im",
	}
	var imagesTestOriginal = {
		folder: "/MonkeyTurk/obj25/imagepacks/im",
	}
	var imagesSamplePack
	var imagesTestPack
	var frame = {
		current: 0,
		shown: [],
	}
	var sounds = {
		folder: "/MonkeyTurk/sounds/au",
		serial: [0,1,2,3,4],
		buffer: [],
	}
	var boundingBoxesFixation = { x: [], y: [], } //where the fixation dot is on the canvas
	var boundingBoxesTest; //where the test images are on the canvas
	var waitforClick; //variable to hold generator
	var fixationTimer; //variable to hold timer
	var xgrid=[];
	var ygrid=[];
	var xgridcent=[];
	var ygridcent=[];
	var curridx = null;
	var battery = {
		current: 0,
		ldt: [],
	}
	var datafiles=[];
	var ndatafiles2read=5;
// Variables (updatable through parameter file)
	var env = {};
	var trial = {
		subjid: "Test",
		datadir: "/MonkeyTurk/",
		automator: 0, //0=no automation 1=obj25 2=MURI
		takephoto: 0,
	};
	var trialhistory={
		trainingstage: [],
		trainingstagename: "",
		automator_filepath: [], 
		correct: [],
		current: 0,
		startingindex:-1,
		pctcorrect:-1,
		ntrials_running: -1,
		minpctcorrect: -1,
		mintrials: -1,
	}
//================== (end) INITIALIZE VARIABLES ==================//
</script>

<!-- Include external scripts once global variables are declared -->
<script src="mkturkdropbox.js" type="text/javascript"></script>
<script src="mkturkautomator.js" type="text/javascript"></script>
<script src="mkturkble.js" type="text/javascript"></script>
<script src="mkturkfoldernums.js" type="text/javascript"></script>
<script src="mkturkimagedisplay.js" type="text/javascript"></script>

<script>
//================== AUTHENTICATE ==================//
if (isAuthenticated()){
	//Create an instance of Dropbox with the access token
	var dbx = new Dropbox({accessToken: getAccessTokenFromUrl()})
}
else {
	var dbx = new Dropbox({clientId: DBX_CLIENT_ID});
	var dbx_authUrl = dbx.getAuthenticationUrl(DBX_REDIRECT_URI);
	window.location.href = dbx_authUrl //send to Dropbox sign-in screen
}
//================== (end) AUTHENTICATE ==================//

// Button callbacks
//ble button
document.querySelector("button[name=connectble]").addEventListener(
	'touchend',findBLEDevice,false)
document.querySelector("button[name=connectble]").addEventListener(
	'mouseup',findBLEDevice,false)
//no ble button
document.querySelector("button[name=noble]").addEventListener(
	'touchend',skipBLEDevice,false)
document.querySelector("button[name=noble]").addEventListener(
	'mouseup',skipBLEDevice,false)
//done editing button
document.querySelector("button[name=doneEditing]").addEventListener(
	'touchend',doneEditing_listener,false)
document.querySelector("button[name=doneEditing]").addEventListener(
	'mouseup',doneEditing_listener,false)
//done testing button
document.querySelector("button[name=doneTesting]").addEventListener(
	'touchend',doneTesting_listener,false)
document.querySelector("button[name=doneTesting]").addEventListener(
	'mouseup',doneTesting_listener,false)
//headsuptext callback
var textobj = document.getElementById("headsuptext")
textobj.addEventListener('touchend',headsuptext_listener,false)
textobj.addEventListener('mouseup',headsuptext_listener,false)

//================== Initialize Screen/Audio/Video ==================//
	// Prevent window scrolling and bounce back effect
	document.body.addEventListener('touchmove',function(event){
		event.preventDefault();
	}, false);
	//Audio pulses for reward
	var audiocontext = new (window.AudioContext || window.webkitAudioContext)();
	var gainNode = audiocontext.createGain()
	gainNode.connect(audiocontext.destination)
	var devicePixelRatio = window.devicePixelRatio || 1;
	var visiblecanvasobj = document.getElementById("canvas" + canvas.front);
	var visiblecontext = visiblecanvasobj.getContext("2d");
	var backingStoreRatio = visiblecontext.webkitBackingStorePixelRatio ||
	                            visiblecontext.mozBackingStorePixelRatio ||
	                            visiblecontext.msBackingStorePixelRatio ||
	                            visiblecontext.oBackingStorePixelRatio ||
	                            visiblecontext.backingStorePixelRatio || 1;
	var canvasScale = devicePixelRatio/backingStoreRatio;
	
	//Start video stream
	var videoobj = document.getElementById('video');
	videoobj.addEventListener('mousedown',mousedown_listener,false);
	videoobj.addEventListener('touchstart',touchstart_listener,false);
	navigator.getMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
	navigator.getMedia({video: true, audio: false},function(stream){
		videoobj.src=window.URL.createObjectURL(stream);
		videoobj.style.visibility = "hidden";
	},function(err){
		console.log('Problem starting video stream.')
	});
	//Monitor Battery - from: http://www.w3.org/TR/battery-status/
	navigator.getBattery().then(function(batteryobj){
		battery.ldt[battery.current]=[batteryobj.level, batteryobj.dischargingTime, Math.round(performance.now())];
		battery.current++;
		batteryobj.addEventListener('levelchange',function(){
			battery.ldt[battery.current]=[batteryobj.level, batteryobj.dischargingTime, Math.round(performance.now())];
			battery.current++;
		})
	});
//================== (end) Initialize Screen/Audio/Video ==================//
//================== DMS TASK (synchronous FOR loop using GENERATOR) ==================//
// issues for top-level code using async: https://github.com/tc39/ecmascript-asyncawait/issues/9
(async function(){
	//================== CONNECT TO BLE ==================//
	document.querySelector("button[name=connectble]").style.display = "block"
	document.querySelector("button[name=connectble]").style.visibility = "visible"
	document.querySelector("button[name=noble]").style.display = "block"
	document.querySelector("button[name=noble]").style.visibility = "visible"
	await connectBLEButtonPromise()
	document.querySelector("button[name=connectble]").style.display = "none" //if do style.visibility=hidden, element will still occupy space
	document.querySelector("button[name=noble]").style.display = "none"
	// GET PARAMFILE NAME
	subjectdialog.showModal();
	await subjidPromise();	
	await getFileListDropbox2();
	if (datafiles.length < ndatafiles2read){
		ndatafiles2read = datafiles.length;
	}
	paramfile.name = paramfile.dir + trial.subjid + "_params.txt";
	await readParametersfromDropbox2();

	//================== USER CAN EDIT PARAMS ==================//
	// ALLOW USER TO EDIT PARAMETERS BEFORE STARTING TASK (enter weight, change reward, etc)
	ble.statustext = paramfile.text
	updateStatusText()
	document.querySelector("p[id=headsuptext]").setAttribute("contentEditable",true)
	document.querySelector("button[name=doneEditing]").style.display = "block"
	document.querySelector("button[name=doneEditing]").style.visibility = "visible"
	
	await editParamsPromise()
	document.querySelector("button[name=doneEditing]").style.display = "none"
	var textobj = document.getElementById("headsuptext")
	textobj.removeEventListener('touchend',headsuptext_listener)
	textobj.removeEventListener('mouseup',headsuptext_listener)
	document.querySelector("p[id=headsuptext]").setAttribute("contentEditable",false)
	if (trial.need2writeParameters == 1){
		paramfile.text = document.getElementById("headsuptext").innerHTML //get the new params
		await writeParameterTexttoDropbox2() //write the new params
		await readParametersfromDropbox2(); // then read them 
	}

	// Initialize SR automator
	if (trial.automator == "OR"){
		updateORTask() // Set trial.[stuff] based on automator's current stage.
		if (trial.need2writeParameters == 1 || trial.automatorstagechange == 1){
			await writeParameterstoDropbox2() // Write trial.[stuff] automator to disk (to params file)
			await readParametersfromDropbox2(); // Then, just to be safe, read them from disk.	
		}
	}
	else if (trial.automator == "SR"){

		// Automator sequence settings: 
		var minpctcorrect_sequence;
		var mintrials_sequence;
		var sample_foldernum_sequence;
		var objectlist_sequence;
		var number_automator_stages; 

		await readAutomatorFilefromDropbox2() // Load automator settings. 
		updateSRTask() // Set trial.[stuff] based on automator's current stage.
		if (trial.need2writeParameters == 1 || trial.automatorstagechange == 1){
			await writeParameterstoDropbox2() // Write trial.[stuff] automator to disk (to params file)
			await readParametersfromDropbox2(); // Then, just to be safe, read them from disk.	
		}
	}
	//================== (end) USER CAN EDIT PARAMS ==================//

	// show button for stopping test trials & starting data saving
	trial.savedata = 0
	document.querySelector("button[name=doneTesting]").style.display = "block"
	document.querySelector("button[name=doneTesting]").style.visibility = "visible"
	// Read performance history
	trial.currentAutomator = trial.automator;
	for (i=0; i <= ndatafiles2read - 1; i++){
		await readPerformanceHistoryfromDropbox2(ndatafiles2read - i - 1);
	}
	trial.automatorstagechange = 0
	trial.need2loadParameters = 1;
	trial.purge = 1
	trial.need2loadImages = 1;
	trial.need2writeParameters = 0;
	//Load sounds
	soundpromises = sounds.serial.map(loadSoundfromDropbox2); //create array of sound load Promises
	await Promise.all(soundpromises); //simultaneously evaluate array of sound load promises
	ble.statustext=""
	updateStatusText()

// =========================================================================================== // 
// ========= MAIN LOOP ============= MAIN LOOP ============ MAIN LOOP ============= MAIN LOOP  // 
// ===========================================================================================  
for (trial.current=0; trial.current<10000; trial.current++){

//============ PARAMETER LOADING ============//
if (trial.automatorstagechange == 1){
	trial.need2loadParameters=1
	trial.need2loadImages=1
}
if (trial.need2loadParameters == 1){
	if (trial.automatorstagechange==0){
		await readParametersfromDropbox2();
	} //if parameters updated outside of automator through parameter file
	console.log("Objects:"+trial.objectlist)
	canvas.tsequence = [0,100,100+trial.sampleON,100+trial.sampleON+trial.sampleOFF]; //timing between frames
	imagesSample.folderOriginal = "/MonkeyTurk/obj25/imagepacks" + trial.imageFolderSample + "/im";
	imagesTest.folderOriginal = "/MonkeyTurk/obj25/imagepacks" + trial.imageFolderTest + "/im";
	imagesSample.folder = "/MonkeyTurk/obj25/imagepacks" + trial.imageFolderSample + "/imp";
	imagesTest.folder = "/MonkeyTurk/obj25/imagepacks" + trial.imageFolderTest + "/imp";
	imagesSample.scale = trial.sampleScale;
	imagesTest.scale = trial.testScale;
	setReward(); canvas.tsequencepost[2] = canvas.tsequencepost[1]+trial.reward*1000;
	if (trial.objectgrid.length == trial.objectlist.length){
		//use object grid
		trial.testgrid = trial.testgrid.slice(0,trial.objectgrid.length)
	}
	if (trial.fixationmove==0){
		trial.fixationinterval = 3000;
	}
	else {
		trial.fixationinterval=trial.fixationmove;
	}
	if (env.species == "macaque" || env.species == "human"){
		canvas.headsupfraction=0;
	}
	else if (env.species == "marmoset"){
		canvas.headsupfraction=1/3-0.06;
	}
	setupCanvasHeadsUp()
	windowWidth = window.innerWidth; // get true window dimensions at last moment
	windowHeight = window.innerHeight;
	if (canvas.headsupfraction > 0){
		videoobj.style.height=canvas.offsettop + "px";
	}
	else if (canvas.headsupfraction == 0 && trial.takephoto == 0){
		videoobj.remove();
	}
	if (trial.takephoto == 1){
		videoobj.visibility="visible"
		videoobj.play();
	}
	for (i = 0; i <= canvas.punish; i++) {setupCanvas(i);}
	if (devicePixelRatio !== 1){
		scaleCanvasforHiDPI(canvas.sample);
		scaleCanvasforHiDPI(canvas.test);
	}
	renderEyeFixation();
	renderReward();
	renderPhotoReward();
	renderPunish();
	renderBlank();
	trial.need2loadParameters = 0;
	trial.purge = 1
} //============ (end) PARAMETER LOADING ============//
// Purge trial tracking variables & initialize data file
if (trial.purge == 1){
	//reset trial tracking variables
	var d = new Date;
	var currdate = d
	var datestr = d.toISOString();
	trial.filename = datestr.slice(0,datestr.indexOf(".")) + "_" + trial.subjid + ".txt";
	trial.current=0;
	trial.fixationgrid=[];
	trial.sample=[];
	trial.test=[];
	trial.sampleserial=[];
	trial.testserial=[];
	trial.tstart=[]
	trial.xytfixation=[];
	trial.allxytfixation=[]
	trial.xytresponse=[];
	trial.response=[];
	trial.correctItem=[];
	trial.sampleblockidx=0;
	trial.stickyresponse=0;
	trial.consecutivehits=0;
	trial.nreward=[];
	trial.purge = 0
}
//============ IMAGE LOADING ============//
if (trial.need2loadImages == 1){
	// SELECT IMAGES
		funcreturn = getImageList(imagesSample,trial.imageFolderSample);
		imagesSample = funcreturn.images;
		imagesSamplePack = funcreturn.imagesPack;
		funcreturn = getImageList(imagesTest,trial.imageFolderTest);
		imagesTest = funcreturn.images;
		imagesTestPack = funcreturn.imagesPack;
	// SELECT IMAGES (end)
	// LOAD IMAGES
		imageSamplepromises = imagesSamplePack.packserial.map(loadSampleImagefromDropbox2); //create array of image load Promises
		await Promise.all(imageSamplepromises); //simultaneously evaluate array of image load promises
		imageTestpromises = imagesTestPack.packserial.map(loadTestImagefromDropbox2); //create array of image load Promises
		await Promise.all(imageTestpromises); //simultaneously evaluate array of image load promises
		// pixel locations of image within pack
		imageOriginalPromises = [
			loadOriginalSampleImagefromDropbox2(0),
			loadOriginalTestImagefromDropbox2(0)
			]
		await Promise.all(imageOriginalPromises)
		imagesSample.wd = imagesSampleOriginal[0].width
		imagesSample.ht = imagesSampleOriginal[0].height
		imagesTest.wd = imagesTestOriginal[0].width
		imagesTest.ht = imagesTestOriginal[0].height
		for (i = 0; i<= imagesSample.serial.length-1; i++){
			imagesSample.pixLR[i] = [imagesSample.packpos[i] * imagesSample.wd, (imagesSample.packpos[i]+1) * imagesSample.wd - 1];
		}
		for (i = 0; i<= imagesTest.serial.length-1; i++){
			imagesTest.pixLR[i] = [imagesTest.packpos[i] * imagesTest.wd, (imagesTest.packpos[i]+1) * imagesTest.wd - 1];
		}
	// LOAD IMAGES (end)
	//----------- MAKE THE IMAGE DISPLAY GRID (3x3)
	var cnt=0;
	for (var i=1; i<=trial.ngridpoints; i++){
		for (var j=1; j<=trial.ngridpoints; j++){
			xgrid[cnt]=i - 1/2;
			ygrid[cnt]=j - 1/2;
			cnt++;
		}
	}

	//center x & y grid within canvas
	var dx = (document.body.clientWidth - canvas.offsetleft)*devicePixelRatio/2/canvasScale - trial.ngridpoints/2*imagesSample.wd*trial.gridscale/canvasScale;
	var dy = (document.body.clientHeight - canvas.offsettop)*devicePixelRatio/2/canvasScale - trial.ngridpoints/2*imagesSample.ht*trial.gridscale/canvasScale;
	for (var i=0; i<=xgrid.length-1; i++){
		xgridcent[i]=Math.round(xgrid[i]*imagesSample.wd*trial.gridscale/canvasScale + dx);
		ygridcent[i]=Math.round(ygrid[i]*imagesSample.ht*trial.gridscale/canvasScale + dy);
	}
	//----------- MAKE THE IMAGE DISPLAY GRID (end)

	// renderBlank();
	renderEyeFixation();
	renderReward();
	renderPhotoReward();
	renderPunish();
	renderBlank();
	trial.need2loadImages = 0;
} 
//============ (end) IMAGE LOADING  ============//
trial.automatorstagechange=0
//============ CHOOSE SAMPLE & TEST ============//
	if (trial.sampleblockidx == 0){
		trial.sample[trial.current] = Math.floor((imagesSample.serial.length)*Math.random());
	} //randomly choose sample
	else if (trial.sampleblockidx <= trial.sampleblocksize-1){
		trial.sample[trial.current] = trial.sample[trial.current-1];
	} //keep same sample
	trial.sampleblockidx++;
	if (trial.sampleblockidx > trial.sampleblocksize-1){
		trial.sampleblockidx = 0;
	} //reset
	//CHOOSE TEST
	funcreturn=getTest(trial.nway);
	if (trial.stickyresponse >= trial.nstickyresponse){
		while (funcreturn.correctItem == trial.response[trial.current-1]){
			funcreturn=getTest(trial.nway);
		} //redraw so that correct item is on opposite side of sticky response
	}
	trial.test[trial.current]=funcreturn.testArray;
	trial.correctItem[trial.current]=funcreturn.correctItem;
	//GET IMAGE SERIALS
	trial.sampleserial[trial.current]=imagesSample.serial[trial.sample[trial.current]];
	var testserial=[];
	for (var q in trial.test[trial.current]){
		testserial[q]=imagesTest.serial[trial.test[trial.current][q]];
	}
	trial.testserial[trial.current]=testserial;
//============ (end) CHOOSE SAMPLE & TEST ============//
//============ FIXATION SCREEN ============//
canvas.buffered=0;
trial.allxytfixation.push([])
if (trial.fixationdur <= 0){
	bufferTrialImages()

	trial.waitingforFixation=0
	trial.fixationgrid[trial.current]=-1;
	trial.tstart[trial.current]=Math.round(performance.now());
	trial.xytfixation[trial.current]=[-1,-1,trial.tstart[trial.current]];
	trial.allxytfixation[trial.current][0] = [-1,-1,trial.tstart[trial.current]]
}
else if (trial.fixationdur > 0){
	trial.waitingforFixation=trial.fixedratio;
}
trial.fixationradius = imagesSample.wd * trial.fixationScale / 2 / canvasScale
while (trial.waitingforFixation > 0){	
	trial.stage=0;
	if (trial.takephoto==1){
	// takephoto2(trial.current,trial.stage); //before fixation
	}

	//------ BUFFER FIXATION, SAMPLE, TEST
	if (trial.fixationmove > 0){
		trial.fixationgrid[trial.current]=Math.floor((xgrid.length)*Math.random()); //Choose grid point
	}
	else if (trial.fixationmove == 0){
		trial.fixationgrid[trial.current]=trial.fixationgridindex;
	}
	if (trial.fixationusessample == 0){
		renderTouchFixation();
	} //draw touch circle for fixation instead of drawing from sample images
	if (canvas.buffered == 0){
		bufferTrialImages();
	}
	if (trial.fixationusessample == 1){
		while (canvas.buffered == 0){
			//wait for sample image to be rendered on fixation canvas
		}
	}
	//------ BUFFER FIXATION, SAMPLE, TEST (end)

	//fixation
	trial.tstart[trial.current]=Math.round(performance.now());
	frame.shown=[];
	for (var q in canvas.sequencepre){frame.shown[q]=0}; frame.current=0;
	if (env.species == 'marmoset'){
		playSound(0);
	}
	await displayTrial(canvas.sequencepre,canvas.tsequencepre);
	audiocontext.suspend()
	await fixationPromise();

	for (var q in canvas.sequenceblank){frame.shown[q]=0}; frame.current=0;
	if (trial.waitingforFixation > 0){
		trial.fixationimagepresent = 0
		await displayTrial(canvas.sequenceblank,canvas.tsequenceblank);
		trial.fixationimagepresent = 1
	} //blank out screen
} //while waiting for fixation
//============ (end) FIXATION SCREEN ============//
//============ SAMPLE & TEST SCREEN ============//
	trial.stage=1;
	// sample & test
	if (trial.rewardStage === 1){
	frame.shown=[];
	while (canvas.buffered == 0){
		//wait
	}
	for (var q in canvas.sequence){frame.shown[q]=0}; frame.current=0;
	await displayTrial(canvas.sequence,canvas.tsequence);
	audiocontext.suspend()
	await responsePromise();
	trial.waitingforResponse=0;
	}
//============ (end) SAMPLE & TEST SCREEN ============//
	if (trial.takephoto==1){
	takephoto2(trial.current,trial.stage); //after fixation
	}
//============ REWARD/PUNISH ============//
	trial.stage=2;
			// reward || punish
	frame.shown=[];
	for (var q in canvas.sequencepost){frame.shown[q]=0}; frame.current=0;
	if (trial.rewardStage === 0){
		if (trial.brokeFixation == 0){
			trial.response[trial.current] = trial.correctItem[trial.current];
			canvas.sequencepost[1]=canvas.photoreward;
			canvas.sequencepost[2]=canvas.reward;
			canvas.tsequencepost[2] = canvas.tsequencepost[1]+trial.reward*1000;
			console.log('touched fixation - reward')
		}
		else if (trial.brokeFixation == 1){
			trial.response[trial.current] = -1;
			canvas.sequencepost[1]=canvas.punish;
			canvas.sequencepost[2]=canvas.punish;
			canvas.tsequencepost[2] = trial.punish;
			console.log('Touched outside fixation - punish')
		}
	} //reward fixation
	else if (trial.rewardStage === 1){
		if (trial.response[trial.current] == trial.correctItem[trial.current]){
			canvas.sequencepost[1]=canvas.photoreward;
			canvas.sequencepost[2]=canvas.reward;
			canvas.tsequencepost[2] = canvas.tsequencepost[1]+trial.reward*1000;
			console.log('correct')
		} //reward
		else {
			canvas.sequencepost[1]=canvas.punish;
			canvas.sequencepost[2]=canvas.punish;
			canvas.tsequencepost[2] = trial.punish;
			console.log('WRONG!')
		}//punish
		if (trial.current>0){
			if (trial.response[trial.current]==trial.response[trial.current-1]){
				trial.stickyresponse++;
			}
			else {
				trial.stickyresponse=0;
			}
		}//stuck responding to same side
	} //reward DMS
	//Calculate number of rewards to give
	if (trial.response[trial.current] == trial.correctItem[trial.current] && 
		(trial.current==0 || 
		(trial.rewardStage==0 && 
			trial.xytfixation[trial.current][2] - trial.xytfixation[trial.current-1][2] < trial.consecutivehitsITI) || 
		(trial.rewardStage==1 && 
			trial.xytresponse[trial.current][2] - trial.xytresponse[trial.current-1][2] < trial.consecutivehitsITI))){
			
			trial.consecutivehits++
			trial.nreward[trial.current] = 1 + Math.floor(trial.consecutivehits / trial.nconsecutivehitsforbonus)
		if (trial.nreward[trial.current] > trial.nrewardmax){
			trial.nreward[trial.current] = trial.nrewardmax
		}
	}
	else {
		if (trial.response[trial.current] == trial.correctItem[trial.current]){
			trial.consecutivehits=1;
			trial.nreward[trial.current] = 1;
		}
		else if (trial.response[trial.current] != trial.correctItem[trial.current]){
			trial.consecutivehits=0;
			trial.nreward[trial.current] = 0;
		}	
	}
	console.log('nhits ' + trial.consecutivehits + '  nreward ' + trial.nreward[trial.current])
	// if (trial.takephoto==1){
	// 	takephoto2(trial.current,trial.stage); //before reward delivery
	// }
	// Deliver reward or punish
	frame.shown=[];
	for (var q in canvas.sequencepost){frame.shown[q]=0}; frame.current=0;
	if (canvas.sequencepost[1]==canvas.photoreward && env.species == 'marmoset'){
		for (var q = 0; q <= trial.nreward[trial.current]-1; q++){
			frame.shown=[];
			for (var q2 in canvas.sequencepost){frame.shown[q2]=0}; frame.current=0;
			playSound(2); 
			var p1 = displayTrial(canvas.sequencepost,canvas.tsequencepost)
			if (ble.connected == false){
				await Promise.all([p1])
			}
			else if (ble.connected == true){
				var p2 = writepumpdurationtoBLE(Math.round(trial.reward*1000))
				await Promise.all([p1, p2])
			}
		}
	} 
	if (canvas.sequencepost[1]==canvas.photoreward && (env.species == 'macaque' || env.species == "human")){
		for (var q = 0; q <= trial.nreward[trial.current]-1; q++){
			frame.shown=[];
			for (var q2 in canvas.sequencepost){frame.shown[q2]=0}; frame.current=0;
			playSound(2);
			var p1 = displayTrial(canvas.sequencepost,canvas.tsequencepost)
			var p2 = dispenseReward()
			if (ble.connected == false){
				await Promise.all([p1, p2])
			}
			else if (ble.connected == true){
				var p3 = writepumpdurationtoBLE(Math.round(trial.reward*1000))
				await Promise.all([p1, p2, p3])
			}
		}
	} // play pump sound
	if (canvas.sequencepost[1]==canvas.punish){
		if (env.species == 'marmoset'){
			playSound(3);
		}
		await displayTrial(canvas.sequencepost,canvas.tsequencepost);
		await dispensePunish();
	}
//============ (end) REWARD/PUNISH ============//
	trial.stage=3;
	if (trial.takephoto==1){
		takephoto2(trial.current,trial.stage); //after reward or punish
	}
		
	if (trial.automator != 0){	
		trialhistory.trainingstage[trialhistory.current] = trial.currentAutomatorStage;
		trialhistory.automator_filepath[trialhistory.current] = trial.automatorFilePath
		trial["currentAutomatorStage"]=trialhistory.trainingstage[trialhistory.current];

		if (trial.rewardStage==0 & trial.brokeFixation==0){
			trialhistory.correct[trialhistory.current]=1;
		}
		else if (trial.rewardStage==0 & trial.brokeFixation==1){
			trialhistory.correct[trialhistory.current]=0;
		}
		if (trial.rewardStage==1 & trial.response[trial.current] == trial.correctItem[trial.current]){
			trialhistory.correct[trialhistory.current]=1;
		}
		else if (trial.rewardStage==1) {
			trialhistory.correct[trialhistory.current]=0;
		}
		trialhistory.current++;
	}

	console.log('ready to write data')
	//save data
	if (trial.savedata == 1 && trial.purge == 0){ //wait for next purge before saving
		writeDatatoDropbox2(); //async - no need to wait for data to write			
	}

	// Check if automator needs to update task
	if (trial.automator != 0){
		//Check if subject met criteria to move to next stage
		if (trial.automator=="OR"){
			updateORTask("writeifneeded");
		}
		else if (trial.automator=="SR"){
			updateSRTask("writeifneeded");
		}
		if (trial.need2writeParameters == 1){
			//Moved to next automator stage
			console.log("updating task parameters (new stage or reward)");
			writeParameterstoDropbox2(); // async updating of parameter file, automated task flow continues even if parameter file gets updated later
		}
	}

	// check if new day
	var newdate = new Date;
	if ( (new Date).getDate() != currdate.getDate())
	{
		trial.need2loadParameters = 1
	}
	if (trial.need2loadParameters == 0){
		// Asynchronously check if parameter file was changed by experimenter
		checkParameterFileStatus2()
	}
	updateHeadsUpDisplay(); // async
	updateHeadsUpDisplayAutomator(); //async
	console.log('end of generator iteration' + trial.current);				
	}
	console.log('end of generator for loop');
})(); //async
// }) //spawn
</script>
</body>

<!-- ************ COMMENT SECTION ************ -->
<!-- This code uses generators & promises from ESM6 harmony to implement a state machine.  This is experimental and only supported on modern browsers (see http://caniuse.com/#feat=promises for full support).
The reasons for using this approach are twofold:
(1) Solving the inversion of control with the old way of using async callbacks in javascript (http://blog.getify.com/promises-part-2/)
(2) readability of the code (http://davidwalsh.name/async-generators)
->(1) makes exception handling much easier
->(2) makes the code easier to edit in the future:
		"The main strength of generators is that they provide a single-threaded, synchronous-looking code style, while allowing you to hide the asynchronicity away as an implementation detail. This lets us express in a very natural way what the flow of our program's steps/statements is without simultaneously having to navigate asynchronous syntax and gotchas."
As of 2014.12.01, generators are not supported in safari and not in iOS (even Chrome for iOS is limited to apple webkit).  Could transpile but better to use a native Chrome environment (i.e. android tablet).
// Load audio webkit, see http://middleearmedia.com/controlling-web-audio-api-oscillators/
// var audiocontext = new webkitAudioContext(); // Create audio container with webkit prefix
// In case you're wondering why you can't use the devicePixelRatio to determine the backing store size, the answer is that they aren't guaranteed to match. Despite presenting the same devicePixelRatio value, Chrome and Safari 6 can and do have entirely different approaches for the backing store size (and therefore the webkitBackingStorePixelRatio) on HiDPI devices. The net result is that we can't rely on devicePixelRatio to know how the browser is going to scale images that are written into the canvas.  http://www.html5rocks.com/en/tutorials/canvas/hidpi/
-->
<!-- ************ /COMMENT SECTION ************ -->

</html>