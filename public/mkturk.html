<!doctype html>

<head>
<meta name="mobile-web-app-capable" content="yes"> <!-- full screen https://developer.chrome.com/multidevice/android/installtohomescreen -->

<meta name="viewport" content="width=device-width, user-scalable=no"> <!-- do not allow window rescaling.  To avoid window rescaling in portrait mode, added with=device-width from http://stackoverflow.com/questions/22771523/ipad-w-retina-safari-reported-dimensions-in-landscape-make-no-sense -->

<link rel="manifest" href="mkturkmanifest.json">
<link rel="icon" href="mkturklogo48.png">

<script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js"></script>
<script src="utils.js"></script>

<!-- <script src="mkturkdropbox.js" type="text/javascript"></script>
<script src="mkturkautomator.js" type="text/javascript"></script>
<script src="mkturkble.js" type="text/javascript"></script> -->

<script src="mkturkusersettings.js"></script>
<script src="mkturkimagedisplay.js"></script>

</head>

<!-- ************* BODY *************** -->
<body bgcolor=#7F7F7F>
<div id="canvasdiv" style="position:relative; width:100vw; height:100vh">
	<button name="connectble" style="visibility:hidden; position: absolute; top: 45%; left: 50%; height: 25px; width: 200px; border-radius: 20px">Connect to Bluetooth</button>
	<button name="noble" style="visibility:hidden; position: absolute; top: 55%; left: 50%; height: 25px; width: 100px; border-radius: 20px">No Bluetooth</button>

	<p id="headsuptext" style="z-index:99; position: absolute; left: 1px; top: 1px; height: 40%; width: 60%; font-size: 20px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;"></p>

	<button name="doneEditing" style="visibility:hidden; position: absolute; top: 45%; left: 70%; height: 25px; width: 100px; border-radius: 20px">Done Editing</button>

	<button name="doneTesting" style="visibility:hidden; position: absolute; top: 55%; left: 70%; height: 50px; width: 125px; border-radius: 20px; z-index:101">Done Testing</button>

	<canvas id="canvasheadsup" width="0" height="0" src="" style="z-index:98; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas0" width="0" height="0" src="" style="z-index:99; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas1" width="0" height="0" src="" style="z-index:1; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas2" width="0" height="0" src="" style="z-index:2; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas3" width="0" height="0" src="" style="z-index:3; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas4" width="0" height="0" src="" style="z-index:4; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas5" width="0" height="0" src="" style="z-index:5; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas6" width="0" height="0" src="" style="z-index:6; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas7" width="0" height="0" src="" style="z-index:7; position: absolute; left: 0px; top: 0px;"> </canvas>

	<video id="video" style="z-index:0; position: absolute; right: 0px; top: 0px;"></video>
	<canvas id="canvascapture" width="0" height="0" src="" style="z-index:0; position: absolute; left: 0px; top: 0px;"> </canvas>
</div>
<dialog id="subjid_dialog">
  <p>Subject ID</p>
 
   <!--Pull down menu that will hold file list-->
  <select id="subjid_list">
  	<option value="-1">--</option>
  </select>
</dialog>

<script>
//================== INITIALIZE VARIABLES ==================//
// Variables (general)
	var subjectdialog = document.getElementById("subjid_dialog");
	var subjectlistobj = document.getElementById("subjid_list");
	//populate list
	for (var q=subjectlist.length-1; q>=0; q--){
		// add menu option
		var opt = document.createElement('option');
		opt.value = q;
		opt.innerHTML = subjectlist[q];
		subjectlistobj.appendChild(opt);
	}
	subjectlistobj.addEventListener("change",subjectlist_listener,false);
	var paramfile={
		dir: "/MonkeyTurk/parameterfiles/",
		name: null,
		text: null,
		data: null,
		ver: null,
		date: null,
		datahasChanged: false,
		filehasChanged: false,
	}
	var canvas = {
		blank: 0,
		sample: 1,
		test: 2,
		touchfix: 3,
		eyefix: 4,
		reward: 5,
		photoreward: 6,
		punish: 7,
		front: 0,
		sequenceblank: [0,0],
		tsequenceblank: [0,100],
		sequencepre: [0,3],
		tsequencepre: [0,300],
		sequence: [0,1,0,2], //0=gray 1=sample 2=test 3=touchfix 4=reward 5=punish
		tsequence: [0,100,100+100,100+100+100], //timing between frames
		sequencepost: [0,5,6],
		tsequencepost: [0,25,600],
		buffered: 0,
		headsupfraction: 1/3,
		offsetleft: 0,
		offsettop: 0,
	};
	var imagesSample = {
		folder: "/MonkeyTurk/obj25/imagepacks/imp",
		packsz: 10,
		serial: [],
		obj: [],
		packpointer: [],
		packserial: [],
		packpos: [],
		pixLR: [],
		scale: 1,
	}; //filenames will be placed in images[idx].src
	var imagesTest = {
		folder: "/MonkeyTurk/obj25/imagepacks/imp",
		packsz: 10,
		serial: [],
		obj: [],
		packpointer: [],
		packserial: [],
		packpos: [],
		pixLR: [],
		scale: 1,
	}; //filenames will be placed in imagesProto[idx].src
	var imagesSampleOriginal = {
		folder: "/MonkeyTurk/obj25/imagepacks/im",
	}
	var imagesTestOriginal = {
		folder: "/MonkeyTurk/obj25/imagepacks/im",
	}
	var imagesSamplePack
	var imagesTestPack
	var frame = {
		current: 0,
		shown: [],
	}
	var sounds = {
		folder: "/MonkeyTurk/sounds/au",
		serial: [0,1,2,3,4],
		buffer: [],
	}
	var boundingBoxFixation=[]; //where the fixation dot is on the canvas
	var boundingBoxesTest = []; //where the test images are on the canvas
	var waitforClick; //variable to hold generator
	var fixationTimer; //variable to hold timer
	var xgrid=[];
	var ygrid=[];
	var xgridcent=[];
	var ygridcent=[];
	var curridx = null;
	var battery = {
		current: 0,
		ldt: [],
	}
	var datafiles=[];
	var ndatafiles2read=5;
// Variables (updatable through parameter file)
	var env = {};
	var trial = {
		subjid: "Test",
		automator: 0, //0=no automation 1=obj25 2=MURI
		takephoto: 0,
	};
	var trialhistory={
		trainingstage: [],
		automator_filepath: [], 
		correct: [],
		current: 0,
		startingindex:-1,
		pctcorrect:-1, 
	}
//================== INITIALIZE VARIABLES (end) ==================//
</script>

<!-- Include external scripts once global variables are declared -->
<script src="mkturkdropbox.js" type="text/javascript"></script>
<script src="mkturkautomator.js" type="text/javascript"></script>
<script src="mkturkble.js" type="text/javascript"></script>
<script src="mkturkfoldernums.js" type="text/javascript"></script>

<script>
//================== AUTHENTICATE ==================//
if (isAuthenticated()){
	//Create an instance of Dropbox with the access token
	var dbx = new Dropbox({accessToken: getAccessTokenFromUrl()})
}
else {
	var dbx = new Dropbox({clientId: DBX_CLIENT_ID});
	var dbx_authUrl = dbx.getAuthenticationUrl(DBX_REDIRECT_URI);
	window.location.href = dbx_authUrl //send to Dropbox sign-in screen
}
//================== AUTHENTICATE (end) ==================//
// Button callbacks
document.querySelector("button[name=connectble]").addEventListener(
	'touchend',findBLEDevice,false)
document.querySelector("button[name=connectble]").addEventListener(
	'mouseup',findBLEDevice,false)
document.querySelector("button[name=noble]").addEventListener(
	'touchend',skipBLEDevice,false)
document.querySelector("button[name=noble]").addEventListener(
	'mouseup',skipBLEDevice,false)
document.querySelector("button[name=doneEditing]").addEventListener(
	'touchend',doneEditing_listener,false)
document.querySelector("button[name=doneEditing]").addEventListener(
	'mouseup',doneEditing_listener,false)
document.querySelector("button[name=doneTesting]").addEventListener(
	'touchend',doneTesting_listener,false)
document.querySelector("button[name=doneTesting]").addEventListener(
	'mouseup',doneTesting_listener,false)
var textobj = document.getElementById("headsuptext")
textobj.addEventListener('touchend',headsuptext_listener,false)
textobj.addEventListener('mouseup',headsuptext_listener,false)
//================== Initialize Screen/Audio/Video ==================//
	// Prevent window scrolling and bounce back effect
	document.body.addEventListener('touchmove',function(event){
		event.preventDefault();
	}, false);
	//Audio pulses for reward
	var audiocontext = new (window.AudioContext || window.webkitAudioContext)();
	var gainNode = audiocontext.createGain()
	gainNode.connect(audiocontext.destination)
	var devicePixelRatio = window.devicePixelRatio || 1;
	var visiblecanvasobj = document.getElementById("canvas" + canvas.front);
	var visiblecontext = visiblecanvasobj.getContext("2d");
	var backingStoreRatio = visiblecontext.webkitBackingStorePixelRatio ||
	                            visiblecontext.mozBackingStorePixelRatio ||
	                            visiblecontext.msBackingStorePixelRatio ||
	                            visiblecontext.oBackingStorePixelRatio ||
	                            visiblecontext.backingStorePixelRatio || 1;
	var canvasScale = devicePixelRatio/backingStoreRatio;
	
	//Start video stream
	var videoobj = document.getElementById('video');
	videoobj.addEventListener('mousedown',mousedown_listener,false);
	videoobj.addEventListener('touchstart',touchstart_listener,false);
	navigator.getMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
	navigator.getMedia({video: true, audio: false},function(stream){
		videoobj.src=window.URL.createObjectURL(stream);
		videoobj.style.visibility = "hidden";
	},function(err){
		console.log('Problem starting video stream.')
	});
	//Monitor Battery - from: http://www.w3.org/TR/battery-status/
	navigator.getBattery().then(function(batteryobj){
		battery.ldt[battery.current]=[batteryobj.level, batteryobj.dischargingTime, Math.round(performance.now())];
		battery.current++;
		batteryobj.addEventListener('levelchange',function(){
			battery.ldt[battery.current]=[batteryobj.level, batteryobj.dischargingTime, Math.round(performance.now())];
			battery.current++;
		})
	});
//================== Initialize Screen/Audio/Video (end) ==================//
//================== DMS TASK (synchronous FOR loop using GENERATOR) ==================//
// issues for top-level code using async: https://github.com/tc39/ecmascript-asyncawait/issues/9
(async function(){
	//================== CONNECT TO BLE ==================//
	document.querySelector("button[name=connectble]").style.display = "block"
	document.querySelector("button[name=connectble]").style.visibility = "visible"
	document.querySelector("button[name=noble]").style.display = "block"
	document.querySelector("button[name=noble]").style.visibility = "visible"
	await connectBLEButtonPromise()
	document.querySelector("button[name=connectble]").style.display = "none" //if do style.visibility=hidden, element will still occupy space
	document.querySelector("button[name=noble]").style.display = "none"
	// GET PARAMFILE NAME
	subjectdialog.showModal();
	await subjidPromise();	
	await getFileListDropbox2();
	if (datafiles.length < ndatafiles2read){
		ndatafiles2read = datafiles.length;
	}
	paramfile.name = paramfile.dir + trial.subjid + "_params.txt";
	await readParametersfromDropbox2();


	//================== USER CAN EDIT PARAMS ==================//
	// ALLOW USER TO EDIT PARAMETERS BEFORE STARTING TASK (enter weight, change reward, etc)
	ble.statustext = paramfile.text
	updateStatusText()
	document.querySelector("p[id=headsuptext]").setAttribute("contentEditable",true)
	document.querySelector("button[name=doneEditing]").style.display = "block"
	document.querySelector("button[name=doneEditing]").style.visibility = "visible"
	
	await editParamsPromise()
	document.querySelector("button[name=doneEditing]").style.display = "none"
	var textobj = document.getElementById("headsuptext")
	textobj.removeEventListener('touchend',headsuptext_listener)
	textobj.removeEventListener('mouseup',headsuptext_listener)
	document.querySelector("p[id=headsuptext]").setAttribute("contentEditable",false)
	if (trial.need2writeParameters == 1){
		paramfile.text = document.getElementById("headsuptext").innerHTML //get the new params
		await writeParameterTexttoDropbox2() //write the new params
		await readParametersfromDropbox2(); // then read them 
	}

	// Initialize SR automator
	if (trial.automator == "SR"){

		// Automator sequence settings: 
		var minpctcorrect_sequence;
		var mintrials_sequence;
		var sample_foldernum_sequence;
		var objectlist_sequence;
		var number_automator_stages; 

		await readAutomatorFilefromDropbox2() // Load automator settings. 
		updateSRTask() // Set trial.[stuff] based on automator's current stage.
		await writeParameterstoDropbox2() // Write trial.[stuff] automator to disk (to params file)
		await readParametersfromDropbox2(); // Then, just to be safe, read them from disk. 
	}

	//================== (end) USER CAN EDIT PARAMS ==================//
	// show testing button
	trial.savedata = 0
	document.querySelector("button[name=doneTesting]").style.display = "block"
	document.querySelector("button[name=doneTesting]").style.visibility = "visible"
	// Read performance history
	trial.currentAutomator = trial.automator;
	for (i=0; i <= ndatafiles2read - 1; i++){
		await readPerformanceHistoryfromDropbox2(ndatafiles2read - i - 1);
	}
	trial.automatorstagechange = 0
	trial.need2loadParameters = 1;
	trial.purge = 1
	trial.need2loadImages = 1;
	trial.need2writeParameters = 0;
	//Load sounds
	soundpromises = sounds.serial.map(loadSoundfromDropbox2); //create array of sound load Promises
	await Promise.all(soundpromises); //simultaneously evaluate array of sound load promises
	ble.statustext=""
	updateStatusText()


// =========================================================================================================== // 
// ============ MAIN LOOP ==================================================================================== // 
// =========================================================================================================== // 


// Todo - incorporate a read of imagebags_parameter from paramfile 
// Todo - refactor images into directories, by object. (use perobj to do this automatically)

for (trial.current=0; trial.current<10000; trial.current++){


	//============ PARAMETER LOADING ============//
	if (trial.automatorstagechange == 1){
		trial.need2loadParameters=1
		trial.need2loadImages=1
	}
	if (trial.need2loadParameters == 1){

		if (trial.automatorstagechange==0){
			await readParametersfromDropbox2();
		}

		console.log("Objects:"+trial.objectlist)
		canvas.tsequence = [0,100,100+trial.sampleON,100+trial.sampleON+trial.sampleOFF]; //timing between frames
		imagesSample.folder = "/MonkeyTurk/obj25/imagepacks" + trial.imageFolderSample + "/imp";
		imagesTest.folder = "/MonkeyTurk/obj25/imagepacks" + trial.imageFolderTest + "/imp";
		imagesSample.scale = trial.sampleScale;
		imagesTest.scale = trial.testScale;
		setReward(); canvas.tsequencepost[2] = canvas.tsequencepost[1]+trial.reward*1000;
		if (trial.objectgrid.length == trial.objectlist.length){
			//use object grid
			trial.testgrid = trial.testgrid.slice(0,trial.objectgrid.length)
		}
		if (trial.fixationmove==0){
			trial.fixationinterval = 3000;
		}
		else {
			trial.fixationinterval=trial.fixationmove;
		}
		if (env.species == "macaque" || env.species == "human"){
			canvas.headsupfraction=0;
		}
		else if (env.species == "marmoset"){
			canvas.headsupfraction=1/3-0.06;
		}
		setupCanvasHeadsUp()
		windowWidth = window.innerWidth; // get true window dimensions at last moment
		windowHeight = window.innerHeight;
		if (canvas.headsupfraction > 0){
			videoobj.style.height=canvas.offsettop + "px";
		}
		else if (canvas.headsupfraction == 0 && trial.takephoto == 0){
			videoobj.remove();
		}
		if (trial.takephoto == 1){
			videoobj.visibility="visible"
			videoobj.play();
		}
		for (i = 0; i <= canvas.punish; i++) {setupCanvas(i);}

		if (devicePixelRatio !== 1){
			scaleCanvasforHiDPI(canvas.sample);
			scaleCanvasforHiDPI(canvas.test);
		}
		renderEyeFixation();
		renderReward();
		renderPhotoReward();
		renderPunish();
		renderBlank();
		trial.need2loadParameters = 0;
		trial.purge = 1
	} //============ PARAMETER LOADING (end) ============//
	// Purge trial tracking variables & initialize data file
	if (trial.purge == 1){
		//reset trial tracking variables
		var d = new Date;
		var currdate = d
		var datestr = d.toISOString();
		trial.filename = datestr.slice(0,datestr.indexOf(".")) + "_" + trial.subjid + ".txt";
		trial.current=0;
		trial.fixationgrid=[];
		trial.sample=[];
		trial.test=[];
		trial.sampleserial=[];
		trial.testserial=[];
		trial.tstart=[]
		trial.xytfixation=[];
		trial.xytresponse=[];
		trial.response=[];
		trial.correctItem=[];
		trial.sampleblockidx=0;
		trial.stickyresponse=0;
		trial.consecutivehits=0;
		trial.nreward=[];
		trial.purge = 0
	}
	//============ IMAGE LOADING ============//
	if (trial.need2loadImages == 1){


		// LOAD IMAGES
		console.log('Loading imagebags.')

		// Todo: read samplebags_parameter / testbags_parameter from parameter file: 
		samplebags_parameter = [['/MonkeyTurk/ImageBags/mil_images/varA_batch0obj47/', '/MonkeyTurk/ImageBags/mil_images/varA_batch0obj47/'
		], '/MonkeyTurk/ImageBags/mil_images/varA_batch0obj67/']; 
		var funcreturn = await loadBagfromDropbox(samplebags_parameter)
		samplebag = funcreturn[0]
		samplebag_labels = funcreturn[1]
		samplebag_paths = funcreturn[2]

		testbags_parameter = ['/MonkeyTurk/ImageBags/buttons/white_button512x512.png', '/MonkeyTurk/ImageBags/buttons/white_button512x512.png']; 
		var funcreturn = await loadBagfromDropbox(testbags_parameter)
		testbag = funcreturn[0]
		testbag_labels = funcreturn[1]
		testbag_paths = funcreturn[2]
		
		// Write down dimensions of (assumedly) all images in bag, based on the first image. 
		imagesSample.wd = samplebag[0].width
		imagesSample.ht = samplebag[0].height

		// Write down dimensions of (assumedly) all images in bag, based on the first image. 
		imagesTest.wd = testbag[0].width
		imagesTest.ht = testbag[0].height
			
		console.log('Done loading imagebags.')
		
		// (end) LOAD IMAGES 
		// MAKE THE IMAGE DISPLAY GRID (3x3)
		var cnt=0;
		for (var i=1; i<=3; i++){
			for (var j=1; j<=3; j++){
				xgrid[cnt]=i - 1/2;
				ygrid[cnt]=j - 1/2;
				cnt++;
			}
		}

		//center x & y grid within canvas
		var dx = (document.body.clientWidth - canvas.offsetleft)*devicePixelRatio/2/canvasScale - xgrid[4]*imagesSample.wd*imagesSample.scale/canvasScale;
		var dy = (document.body.clientHeight - canvas.offsettop)*devicePixelRatio/2/canvasScale - ygrid[4]*imagesSample.ht*imagesSample.scale/canvasScale;
		for (var i=0; i<=xgrid.length-1; i++){
			xgridcent[i]=Math.round(xgrid[i]*imagesSample.wd*imagesSample.scale/canvasScale + dx);
			ygridcent[i]=Math.round(ygrid[i]*imagesSample.ht*imagesSample.scale/canvasScale + dy);
		}
		// MAKE THE IMAGE DISPLAY GRID (end)
		// renderBlank();
		console.log('Begin rendering stack.')
		renderEyeFixation();
		renderReward();
		renderPhotoReward();
		renderPunish();
		renderBlank();
		trial.need2loadImages = 0;
		console.log('End rendering stack.')

	} 
	//============ (end) IMAGE LOADING  ============//
	trial.automatorstagechange=0
	//============ CHOOSE SAMPLE & TEST ============//

	// Get sample image according to some SamplingStrategy
	// Store its index in trial.sample[trial.current]

	if (trial.sampleblockidx == 0){ 
		var SamplingStrategy = 'uniform_with_replacement'
		var sampleImage_index = selectSampleImage(samplebag_labels, SamplingStrategy)
		trial.sample[trial.current] = sampleImage_index 
	} 
	// Option: keep sample from last trial
	else if (trial.sampleblockidx <= trial.sampleblocksize-1){
		trial.sample[trial.current] = trial.sample[trial.current-1];
	} 

	trial.sampleblockidx++;
	// Reset sampleblock counter. 
	if (trial.sampleblockidx > trial.sampleblocksize-1){
		trial.sampleblockidx = 0;
	} 

	// Get appropriate test image (correct + distractors) according to some SamplingStrategy
	var current_sample_label = samplebag_labels[trial.sample[trial.current]]; 
	funcreturn = selectTestImages(current_sample_label, trial.nway, testbag_labels) 
	trial.test[trial.current] = funcreturn[0] // Indexes testbag, in some order that will be given on the screen according to trial.TestGrid. 
	trial.correctItem[trial.current] = funcreturn[1] // The rewarded index of trial.test. 

	// TODO
	if (trial.stickyresponse >= trial.nstickyresponse){
		throw "Not implemented"
		// If the number of 'sticky responses' is greater than nstickyresponses, 
		// make sure the correct answer for this trial is not at the sticky location. 
		// Move this into getTestImageIndices?
	}

	//============ (end) CHOOSE SAMPLE & TEST ============//
	//============ FIXATION SCREEN ============//
	canvas.buffered=0;

	var trial_sampleimage = samplebag[trial.sample[trial.current]]
	var trial_testimages = [] 
	for (var i_test = 0; i_test<trial.test[trial.current].length; i_test++){
		trial_testimages.push(testbag[trial.test[trial.current][i_test]])
	}
		
	if (trial.fixationdur <= 0){
		bufferTrialImages(trial_sampleimage, trial.samplegrid, trial_testimages, trial.testgrid)
		trial.waitingforFixation=0
		trial.fixationgrid[trial.current]=-1;
		trial.tstart[trial.current]=Math.round(performance.now());
		trial.xytfixation[trial.current]=[-1,-1,trial.tstart[trial.current]];
	}
	else if (trial.fixationdur > 0){
		trial.waitingforFixation=1;
	}
	while (trial.waitingforFixation==1){
		// CHOOSE FIXATION, SAMPLE, TEST
		
		//CHOOSE FIXATION
		if (trial.fixationmove > 0){
			trial.fixationgrid[trial.current]=Math.floor((xgrid.length)*Math.random()); //Choose grid point
		}
		else if (trial.fixationmove == 0){
			trial.fixationgrid[trial.current]=5;
		}

		//FIXATION
		trial.stage=0;
		if (trial.takephoto==1){
			// takephoto2(trial.current,trial.stage); //before fixation
		}
		//buffer fixation, sample & test
		renderTouchFixation();
		if (canvas.buffered == 0){
			bufferTrialImages(trial_sampleimage, trial.samplegrid, trial_testimages, trial.testgrid);
		}
		//fixation
		trial.tstart[trial.current]=Math.round(performance.now());
		frame.shown=[];
		for (var q in canvas.sequencepre){
			frame.shown[q]=0
		}; 
		frame.current=0;

		if (env.species == 'marmoset'){
			playSound(0);
		}
		await displayTrial(canvas.sequencepre,canvas.tsequencepre);
		audiocontext.suspend()
		await fixationPromise();
		for (var q in canvas.sequenceblank){frame.shown[q]=0}; frame.current=0;
		if (trial.waitingforFixation==1){
			await displayTrial(canvas.sequenceblank,canvas.tsequenceblank);
		}
	} // (end) while waiting for fixation

	//============ (end) FIXATION SCREEN ============//

	//============ SAMPLE & TEST SCREEN ============//
	trial.stage=1;
	// sample & test
	if (trial.rewardStage === 1){
		frame.shown=[];
		while (canvas.buffered == 0){
			continue 
		}
		
		for (var q in canvas.sequence){
			frame.shown[q]=0
		}; 

		frame.current=0;
		await displayTrial(canvas.sequence,canvas.tsequence);
		audiocontext.suspend()
		await responsePromise();
		trial.waitingforResponse=0;
	}
	//============ SAMPLE & TEST SCREEN (end) ============//
	if (trial.takephoto==1){
		// After fixation
		// takephoto2(trial.current,trial.stage); 
	}

	//============ REWARD/PUNISH ============//
	trial.stage=2;
			// reward || punish
	frame.shown=[];
	for (var q in canvas.sequencepost){frame.shown[q]=0}; frame.current=0;
	if (trial.rewardStage === 0){
		if (trial.brokeFixation == 0){
			trial.response[trial.current] = trial.correctItem[trial.current];
			canvas.sequencepost[1]=canvas.photoreward;
			canvas.sequencepost[2]=canvas.reward;
			canvas.tsequencepost[2] = canvas.tsequencepost[1]+trial.reward*1000;
			console.log('touched fixation - reward')
		}
		else if (trial.brokeFixation == 1){
			trial.response[trial.current] = -1;
			canvas.sequencepost[1]=canvas.punish;
			canvas.sequencepost[2]=canvas.punish;
			canvas.tsequencepost[2] = trial.punish;
			console.log('Touched outside fixation - punish')
		}
	} //reward fixation
	else if (trial.rewardStage === 1){ 
		// Give reward if correct

		// trial.response indexes boundingBoxesTest
		if (trial.response[trial.current] == trial.correctItem[trial.current]){
			canvas.sequencepost[1]=canvas.photoreward;
			canvas.sequencepost[2]=canvas.reward;
			canvas.tsequencepost[2] = canvas.tsequencepost[1]+trial.reward*1000;
			console.log('correct')
		} 
		else { // Give punishment
			canvas.sequencepost[1]=canvas.punish;
			canvas.sequencepost[2]=canvas.punish;
			canvas.tsequencepost[2] = trial.punish;
			console.log('WRONG!')
		}

		if (trial.current>0){
			if (trial.response[trial.current]==trial.response[trial.current-1]){
				trial.stickyresponse++;
			}
			else {
				trial.stickyresponse=0;
			}
		}//stuck responding to same side
	} //reward DMS
	//Calculate number of rewards to give
	if (trial.response[trial.current] == trial.correctItem[trial.current] && 
		(trial.current==0 || 
		(trial.rewardStage==0 && 
			trial.xytfixation[trial.current][2] - trial.xytfixation[trial.current-1][2] < trial.consecutivehitsITI) || 
		(trial.rewardStage==1 && 
			trial.xytresponse[trial.current][2] - trial.xytresponse[trial.current-1][2] < trial.consecutivehitsITI))){
			
			trial.consecutivehits++
			trial.nreward[trial.current] = 1 + Math.floor(trial.consecutivehits / trial.nconsecutivehitsforbonus)
		if (trial.nreward[trial.current] > trial.nrewardmax){
			trial.nreward[trial.current] = trial.nrewardmax
		}
	}
	else {
		if (trial.response[trial.current] == trial.correctItem[trial.current]){
			trial.consecutivehits=1;
			trial.nreward[trial.current] = 1;
		}
		else if (trial.response[trial.current] != trial.correctItem[trial.current]){
			trial.consecutivehits=0;
			trial.nreward[trial.current] = 0;
		}	
	}
	console.log('nhits ' + trial.consecutivehits + '  nreward ' + trial.nreward[trial.current])
	// if (trial.takephoto==1){
	// 	takephoto2(trial.current,trial.stage); //before reward delivery
	// }
	// Deliver reward or punish
	frame.shown=[];
	for (var q in canvas.sequencepost){frame.shown[q]=0}; frame.current=0;
	if (canvas.sequencepost[1]==canvas.photoreward && env.species == 'marmoset'){
		for (var q = 0; q <= trial.nreward[trial.current]-1; q++){
			frame.shown=[];
			for (var q2 in canvas.sequencepost){frame.shown[q2]=0}; frame.current=0;
			playSound(2); 
			var p1 = displayTrial(canvas.sequencepost,canvas.tsequencepost)
			if (ble.connected == false){
				await Promise.all([p1])
			}
			else if (ble.connected == true){
				var p2 = writepumpdurationtoBLE(Math.round(trial.reward*1000))
				await Promise.all([p1, p2])
			}
		}
	} 
	if (canvas.sequencepost[1]==canvas.photoreward && (env.species == 'macaque' || env.species == "human")){
		for (var q = 0; q <= trial.nreward[trial.current]-1; q++){
			frame.shown=[];
			for (var q2 in canvas.sequencepost){frame.shown[q2]=0}; frame.current=0;
			playSound(2);
			var p1 = displayTrial(canvas.sequencepost,canvas.tsequencepost)
			var p2 = dispenseReward()
			if (ble.connected == false){
				await Promise.all([p1, p2])
			}
			else if (ble.connected == true){
				var p3 = writepumpdurationtoBLE(Math.round(trial.reward*1000))
				await Promise.all([p1, p2, p3])
			}
		}
	} // play pump sound
	if (canvas.sequencepost[1]==canvas.punish){
		if (env.species == 'marmoset'){
			playSound(3);
		}
		await displayTrial(canvas.sequencepost,canvas.tsequencepost);
		await dispensePunish();
	}
	//============ REWARD/PUNISH (end) ============//
	trial.stage=3;
	if (trial.takephoto==1){
		takephoto2(trial.current,trial.stage); //after reward or punish
	}
		
	if (trial.automator != 0 && trial.savedata == 1){	
		trialhistory.trainingstage[trialhistory.current] = trial.currentAutomatorStage;
		trialhistory.automator_filepath[trialhistory.current] = trial.automatorFilePath
		trial["currentAutomatorStage"]=trialhistory.trainingstage[trialhistory.current];

		if (trial.rewardStage==0 & trial.brokeFixation==0){
		trialhistory.correct[trialhistory.current]=1;
		}
		else if (trial.rewardStage==0 & trial.brokeFixation==1){
			trialhistory.correct[trialhistory.current]=0;
		}
		if (trial.rewardStage==1 & trial.response[trial.current] == trial.correctItem[trial.current]){
				trialhistory.correct[trialhistory.current]=1;
		}
		else if (trial.rewardStage==1) {
			trialhistory.correct[trialhistory.current]=0;
		}
		trialhistory.current++;
	}

		
		console.log('ready to write data')
		//save data
		if (trial.savedata == 1 && trial.purge == 0){ //wait for next purge before saving
			writeDatatoDropbox2(); //async - no need to wait for data to write			
		}
		updateHeadsUpDisplay(); // async
		console.log('end of generator iteration' + trial.current);			
	// Check if automator needs to update task
	if (trial.automator != 0){
		//Check if subject met criteria to move to next stage
		if (trial.automator==1){
			updateTask1("writeifneeded");
		}
		else if (trial.automator==2){
			updateTask2("writeifneeded");
		}
		else if (trial.automator==3){
			updateTask3("writeifneeded");
		}
		else if (trial.automator=="SR"){
			updateSRTask("writeifneeded");
		}
		if (trial.need2writeParameters == 1){
			//Moved to next automator stage
			console.log("updating task parameters (new stage or reward)");
			writeParameterstoDropbox2(); // async updating of parameter file, automated task flow continues even if parameter file gets updated later
		}
	}
	// check if new day
	var newdate = new Date;
	if ( (new Date).getDate() != currdate.getDate()){
		trial.need2loadParameters = 1
	}
	if (trial.need2loadParameters == 0){
		// Asynchronously check if parameter file was changed by experimenter
		checkParameterFileStatus2()
	}
} // End iteration of main loop 
	console.log('end of generator for loop');
})(); //async
// }) //spawn
</script>
</body>

<!-- ************ COMMENT SECTION ************ -->
<!-- This code uses generators & promises from ESM6 harmony to implement a state machine.  This is experimental and only supported on modern browsers (see http://caniuse.com/#feat=promises for full support).
The reasons for using this approach are twofold:
(1) Solving the inversion of control with the old way of using async callbacks in javascript (http://blog.getify.com/promises-part-2/)
(2) readability of the code (http://davidwalsh.name/async-generators)
->(1) makes exception handling much easier
->(2) makes the code easier to edit in the future:
		"The main strength of generators is that they provide a single-threaded, synchronous-looking code style, while allowing you to hide the asynchronicity away as an implementation detail. This lets us express in a very natural way what the flow of our program's steps/statements is without simultaneously having to navigate asynchronous syntax and gotchas."
As of 2014.12.01, generators are not supported in safari and not in iOS (even Chrome for iOS is limited to apple webkit).  Could transpile but better to use a native Chrome environment (i.e. android tablet).
// Load audio webkit, see http://middleearmedia.com/controlling-web-audio-api-oscillators/
// var audiocontext = new webkitAudioContext(); // Create audio container with webkit prefix
// In case you're wondering why you can't use the devicePixelRatio to determine the backing store size, the answer is that they aren't guaranteed to match. Despite presenting the same devicePixelRatio value, Chrome and Safari 6 can and do have entirely different approaches for the backing store size (and therefore the webkitBackingStorePixelRatio) on HiDPI devices. The net result is that we can't rely on devicePixelRatio to know how the browser is going to scale images that are written into the canvas.  http://www.html5rocks.com/en/tutorials/canvas/hidpi/
-->
<!-- ************ /COMMENT SECTION ************ -->

</html>