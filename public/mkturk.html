<!doctype html>

<head>
<meta name="mobile-web-app-capable" content="yes"> <!-- full screen https://developer.chrome.com/multidevice/android/installtohomescreen -->
<meta name="viewport" content="width=device-width, user-scalable=no"> <!-- do not allow window rescaling.  To avoid window rescaling in portrait mode, added with=device-width from http://stackoverflow.com/questions/22771523/ipad-w-retina-safari-reported-dimensions-in-landscape-make-no-sense -->

<link rel="manifest" href="mkturkmanifest.json">
<link rel="icon" href="mkturklogo48.png">

<script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js"></script>
<script src="utils.js"></script>

<!-- <script src="mkturkdropbox.js" type="text/javascript"></script>
<script src="mkturkautomator.js" type="text/javascript"></script>
<script src="mkturkble.js" type="text/javascript"></script> -->

<script src="mkturkusersettings.js"></script>
<script src="mkturkimagedisplay.js"></script>

</head>

<!-- ************* BODY *************** -->
<body bgcolor=#7F7F7F>
<div id="canvasdiv" style="position:relative; width:100vw; height:100vh">
	<button name="connectble" style="visibility:hidden; position: absolute; top: 45%; left: 45%; height: 100px; width: 200px; border-radius: 20px">Connect to Bluetooth juicer</button>
	<button name="noble" style="visibility:hidden; position: absolute; top: 55%; left: 45%; height: 100px; width: 200px; border-radius: 20px">No Bluetooth juicer</button>

	<p id="headsuptext" style="z-index:99; position: absolute; left: 1px; top: 1px; height: 40%; width: 60%; font-size: 20px; color: white; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;"></p>

	<button name="doneEditing" style="visibility:hidden; position: absolute; top: 45%; left: 70%; height: 100px; width: 100px; border-radius: 20px">Done editing params</button>

	<button name="doneTesting" style="visibility:hidden; position: absolute; top: 55%; left: 70%; height: 100px; width: 200px; border-radius: 20px; z-index:101">Done with testing</button>

	<canvas id="canvasheadsup" width="0" height="0" src="" style="z-index:98; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas0" width="0" height="0" src="" style="z-index:99; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas1" width="0" height="0" src="" style="z-index:1; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas2" width="0" height="0" src="" style="z-index:2; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas3" width="0" height="0" src="" style="z-index:3; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas4" width="0" height="0" src="" style="z-index:4; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas5" width="0" height="0" src="" style="z-index:5; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas6" width="0" height="0" src="" style="z-index:6; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvas7" width="0" height="0" src="" style="z-index:7; position: absolute; left: 0px; top: 0px;"> </canvas>
	<canvas id="canvascapture" width="0" height="0" src="" style="z-index:0; position: absolute; left: 0px; top: 0px;"> </canvas>
</div>
<dialog id="subjectID_dialog">
  <p>Select subject: </p>
 
   <!--Pull down menu that will hold file list-->
  <select id="subjectID_list">
  	<option value="-1">--</option>
  </select>
</dialog>


<script src="mkturkvariables.js"></script>
<script src="mkturkdropbox.js" type="text/javascript"></script>
<script src="mkturkautomator.js" type="text/javascript"></script>
<script src="mkturkble.js" type="text/javascript"></script>


<script>
//================== AUTHENTICATE ==================//
if (isAuthenticated()){
	//Create an instance of Dropbox with the access token
	var dbx = new Dropbox({accessToken: getAccessTokenFromUrl()})
}
else {
	var dbx = new Dropbox({clientId: DBX_CLIENT_ID});
	var dbx_authUrl = dbx.getAuthenticationUrl(DBX_REDIRECT_URI);
	window.location.href = dbx_authUrl //send to Dropbox sign-in screen
}
//================== AUTHENTICATE (end) ==================//
// Button callbacks
document.querySelector("button[name=connectble]").addEventListener(
	'touchend',findBLEDevice,false)
document.querySelector("button[name=connectble]").addEventListener(
	'mouseup',findBLEDevice,false)
document.querySelector("button[name=noble]").addEventListener(
	'touchend',skipBLEDevice,false)
document.querySelector("button[name=noble]").addEventListener(
	'mouseup',skipBLEDevice,false)
document.querySelector("button[name=doneEditing]").addEventListener(
	'touchend',doneEditing_listener,false)
document.querySelector("button[name=doneEditing]").addEventListener(
	'mouseup',doneEditing_listener,false)
document.querySelector("button[name=doneTesting]").addEventListener(
	'touchend',doneTesting_listener,false)
document.querySelector("button[name=doneTesting]").addEventListener(
	'mouseup',doneTesting_listener,false)
var textobj = document.getElementById("headsuptext")
textobj.addEventListener('touchend',headsuptext_listener,false)
textobj.addEventListener('mouseup',headsuptext_listener,false)
//================== Initialize Screen/Audio/Video ==================//
	// Prevent window scrolling and bounce back effect
	document.body.addEventListener('touchmove',function(event){
		event.preventDefault();
	}, false);
	//Audio pulses for reward
	var audiocontext = new (window.AudioContext || window.webkitAudioContext)();
	var gainNode = audiocontext.createGain()
	gainNode.connect(audiocontext.destination)
	var devicePixelRatio = window.devicePixelRatio || 1;
	var visiblecanvasobj = document.getElementById("canvas" + canvas.front);
	var visiblecontext = visiblecanvasobj.getContext("2d");
	var backingStoreRatio = visiblecontext.webkitBackingStorePixelRatio ||
	                            visiblecontext.mozBackingStorePixelRatio ||
	                            visiblecontext.msBackingStorePixelRatio ||
	                            visiblecontext.oBackingStorePixelRatio ||
	                            visiblecontext.backingStorePixelRatio || 1;
	var canvasScale = devicePixelRatio/backingStoreRatio;
	
	//Monitor Battery - from: http://www.w3.org/TR/battery-status/
	navigator.getBattery().then(function(batteryobj){
		battery.ldt[battery.current]=[batteryobj.level, batteryobj.dischargingTime, Math.round(performance.now())];
		battery.current++;
		batteryobj.addEventListener('levelchange',function(){
			battery.ldt[battery.current]=[batteryobj.level, batteryobj.dischargingTime, Math.round(performance.now())];
			battery.current++;
		})
	});
//================== Initialize Screen/Audio/Video (end) ==================//
// issues for top-level code using async: https://github.com/tc39/ecmascript-asyncawait/issues/9
(async function(){
	//================== CONNECT TO BLE ==================//
	document.querySelector("button[name=connectble]").style.display = "block"
	document.querySelector("button[name=connectble]").style.visibility = "visible"
	document.querySelector("button[name=noble]").style.display = "block"
	document.querySelector("button[name=noble]").style.visibility = "visible"
	await connectBLEButtonPromise()
	document.querySelector("button[name=connectble]").style.display = "none" //if do style.visibility=hidden, element will still occupy space
	document.querySelector("button[name=noble]").style.display = "none"
	
	// GET PARAMFILE NAME
	console.log('hello1')
	subjectdialog.showModal();
	await subjectIDPromise();	
	TASK.paramfile = PARAM_DIRPATH + TASK.subjectID + "_params.txt";
	console.log(TASK.paramfile )
	await loadParametersfromDropbox(TASK.paramfile);
	console.log('hello2')

	//================== USER CAN EDIT PARAMS ==================//
	ble.statustext = await loadTextFilefromDropbox(TASK.paramfile)
	updateStatusText(ble.statustext)
	document.querySelector("p[id=headsuptext]").setAttribute("contentEditable",true)
	document.querySelector("button[name=doneEditing]").style.display = "block"
	document.querySelector("button[name=doneEditing]").style.visibility = "visible"
	
	await editParamsPromise()
	document.querySelector("button[name=doneEditing]").style.display = "none"
	var textobj = document.getElementById("headsuptext")
	textobj.removeEventListener('touchend',headsuptext_listener)
	textobj.removeEventListener('mouseup',headsuptext_listener)
	document.querySelector("p[id=headsuptext]").setAttribute("contentEditable",false)

	if (FLAGS.need2writeParameters == 1){
		var user_param_text = document.getElementById("headsuptext").innerHTML 		
		await writeParameterTexttoDropbox(user_param_text) 
		await loadParametersfromDropbox(TASK.paramfile);
	}

	//================== TEST MODE ==================//
	FLAGS.savedata = 0
	document.querySelector("button[name=doneTesting]").style.display = "block"
	document.querySelector("button[name=doneTesting]").style.visibility = "visible"

	// Read performance history
	var subject_behavior_save_directory = DATA_SAVEPATH + TASK.subjectID + '/'
	var history_file_paths = await getMostRecentBehavioralFilePathsFromDropbox(ndatafiles2read, TASK.subjectID, subject_behavior_save_directory)
	var trialhistory = await readTrialHistoryFromDropbox(history_file_paths);

	// Initialize automator
	if (TASK.automator != 0){
		automator_data = await parseAutomatorFilefromDropbox(TASK.automatorFilePath) 
		console.log('before', TASK.paramfile)
		automateTask(automator_data, trialhistory) 
		console.log('after', TASK.paramfile)
		console.log('save:', TASK.paramfile)
		await saveParameterstoDropbox() 
		console.log('load:')
		await loadParametersfromDropbox(TASK.paramfile); 
	}

	//Load sounds
	soundpromises = sounds.serial.map(loadSoundfromDropbox2); //create array of sound load Promises
	await Promise.all(soundpromises); //simultaneously evaluate array of sound load promises
	updateStatusText("")

	

// =========================================================================================================== // 
// ============ MAIN LOOP ==================================================================================== // 
// =========================================================================================================== // 
FLAGS.need2loadParameters = 1
FLAGS.current_trial = -1

while(true){
	FLAGS.current_trial++

	//============ PARAMETER LOADING ============//
	if (FLAGS.need2loadParameters == 1){
		await loadParametersfromDropbox(TASK.paramfile);
		FLAGS.need2loadParameters = 0; 	
	}

	canvas.tsequence = [0,100,100+TASK.sampleON,100+TASK.sampleON+TASK.sampleOFF]; 
	TASK.reward = setReward(); 
	canvas.tsequencepost[2] = canvas.tsequencepost[1]+TASK.reward*1000;

	
	if (TASK.species == "macaque" || TASK.species == "human"){
		canvas.headsupfraction=0;
	}
	else if (TASK.species == "marmoset"){
		canvas.headsupfraction=1/3-0.06;
	}
	setupCanvasHeadsUp()
	windowWidth = window.innerWidth; // get true window dimensions at last moment
	windowHeight = window.innerHeight;
	
	for (i = 0; i <= canvas.punish; i++) {setupCanvas(i);}

	if (devicePixelRatio !== 1){
		scaleCanvasforHiDPI(canvas.sample);
		scaleCanvasforHiDPI(canvas.test);
	}
	renderEyeFixation();
	renderReward();
	renderPhotoReward();
	renderPunish();
	renderBlank();

	// Purge trial tracking variables & initialize data file
	if (FLAGS.purge == 1){
		purgeTrackingVariables()
		FLAGS.purge = 0; 
	}

	//============ IMAGE LOADING ============//
	if (FLAGS.need2loadImages == 1){
		// LOAD IMAGES
		console.log('Beginning to load imagebags:')

		var funcreturn = await loadBagfromDropbox(TASK.imageBagsSample)
		samplebag = funcreturn[0]
		samplebag_labels = funcreturn[1]
		samplebag_paths = funcreturn[2]
		TASK.samplebag_paths = samplebag_paths; 

		var funcreturn = await loadBagfromDropbox(TASK.imageBagsTest)
		testbag = funcreturn[0]
		testbag_labels = funcreturn[1]
		testbag_paths = funcreturn[2]
		TASK.testbag_paths = testbag_paths; 

		// Write down dimensions of (assumedly) all images in bag, based on the first sample image. 
		TASK.wd = samplebag[0].width
		TASK.ht = samplebag[0].height
		
		// MAKE THE IMAGE DISPLAY GRID (3x3)
		funcreturn = defineImageGrid(TASK.ngridpoints, TASK.wd, TASK.ht, TASK.sampleScale, canvasScale); 
		xgrid = funcreturn[0]
		ygrid = funcreturn[1]
		xgridcent = funcreturn[2]
		ygridcent = funcreturn[3]
		
		// renderBlank();
		renderEyeFixation();
		renderReward();
		renderPhotoReward();
		renderPunish();
		renderBlank();
		FLAGS.need2loadImages = 0;
	} 

	//============ CHOOSE SAMPLE & TEST ============//

	// Draw one (1) sample image from samplebag
	var samplingStrategy = 'uniform_with_replacement'
	var sampleImage_index = selectSampleImage(samplebag_labels, samplingStrategy)
	var current_sample_label = samplebag_labels[sampleImage_index]; 
	TRIAL.sample[FLAGS.current_trial] = sampleImage_index 

	// Select appropriate test images (correct one and distractors) 
	funcreturn = selectTestImages(current_sample_label, testbag_labels) 
	TRIAL.test[FLAGS.current_trial] = funcreturn[0] 
	TRIAL.correctItem[FLAGS.current_trial] = funcreturn[1] 

	// Sample: get image blob actual from samplebag
	var trial_sampleimage = samplebag[TRIAL.sample[FLAGS.current_trial]]

	// Test: get image blobs actual from testbag
	var trial_testimages = [] 
	for (var i_test = 0; i_test<TRIAL.test[FLAGS.current_trial].length; i_test++){
		trial_testimages.push(testbag[TRIAL.test[FLAGS.current_trial][i_test]])
	}
	
	// Buffer canvases with these images
	canvas.buffered=0;
	await bufferTrialImages(trial_sampleimage, TASK.sampleGrid, trial_testimages, TASK.testGrid);
	console.log('Done buffering images.')

	//============ FIXATION SCREEN ============//
	
	// If no fixation requirement: 
	if (TASK.fixationDur <= 0){
		FLAGS.waitingforFixation=0

		TRIAL.fixationGrid[FLAGS.current_trial]=-1;
		TRIAL.tstart[FLAGS.current_trial]=Math.round(performance.now());
		TRIAL.xytfixation[FLAGS.current_trial]=[-1,-1,TRIAL.tstart[FLAGS.current_trial]];
	}
	else if (TASK.fixationDur > 0){
		FLAGS.waitingforFixation=1;
	}
	while (FLAGS.waitingforFixation==1){
		
		// Choose fixation grid index
		if (TASK.fixationMove > 0){
			TRIAL.fixationGrid[FLAGS.current_trial]=Math.floor((xgrid.length)*Math.random()); 
		}
		else if (TASK.fixationMove == 0){
			TRIAL.fixationGrid[FLAGS.current_trial]=TASK.fixationGrid;
		}

		// Render fixation dot. 
		FLAGS.stage=0;
		renderTouchFixation();

		// Start timer for this fixation render trial. 
		TRIAL.tstart[FLAGS.current_trial]=Math.round(performance.now());
		frame.shown=[];
		for (var q in canvas.sequencepre){
			frame.shown[q]=0
		}; 
		frame.current=0;

		if (TASK.species == 'marmoset'){
			playSound(0);
		}

		await displayTrial(canvas.sequencepre,canvas.tsequencepre);
		audiocontext.suspend()
		await fixationPromise();
		for (var q in canvas.sequenceblank){
			frame.shown[q]=0
		}; 
		frame.current=0;
		//if (FLAGS.waitingforFixation==1){
			//await displayTrial(canvas.sequenceblank,canvas.tsequenceblank);
		//}
	} 

	//============ SAMPLE & TEST SCREEN ============//
	FLAGS.stage=1;
	// Show sample (then) test:
	if (TASK.rewardStage === 1){
		frame.shown=[];
		while (canvas.buffered == 0){
			console.log('Waiting for buffer...')
			continue 
		}
		
		for (var q in canvas.sequence){
			frame.shown[q]=0
		}; 

		frame.current=0;
		await displayTrial(canvas.sequence,canvas.tsequence);
		audiocontext.suspend()
		await responsePromise();
		FLAGS.waitingforResponse=0;
	}

	//============ REWARD/PUNISH SCREEN ============//
	FLAGS.stage=2;
	frame.shown=[];
	for (var q in canvas.sequencepost){frame.shown[q]=0}; frame.current=0;

	// Fixation task reward/punish screens
	if (TASK.rewardStage === 0){
		console.log("hello 11a - fixation task reward")
		if (FLAGS.brokeFixation == 0){
			TRIAL.response[FLAGS.current_trial] = TRIAL.correctItem[FLAGS.current_trial];
			canvas.sequencepost[1]=canvas.photoreward;
			canvas.sequencepost[2]=canvas.reward;
			canvas.tsequencepost[2] = canvas.tsequencepost[1]+TASK.reward*1000;
			console.log('Touched fixation - reward')
		}
		else if (FLAGS.brokeFixation == 1){
			TRIAL.response[FLAGS.current_trial] = -1;
			canvas.sequencepost[1]=canvas.punish;
			canvas.sequencepost[2]=canvas.punish;
			canvas.tsequencepost[2] = TASK.punish;
			console.log('Touched outside fixation - punish')
		}
	} // Choice task reward/punish screens
	else if (TASK.rewardStage === 1){ 
		console.log("hello 11b - choice task reward")
		if (TRIAL.response[FLAGS.current_trial] == TRIAL.correctItem[FLAGS.current_trial]){
			canvas.sequencepost[1]=canvas.photoreward;
			canvas.sequencepost[2]=canvas.reward;
			canvas.tsequencepost[2] = canvas.tsequencepost[1]+TASK.reward*1000;
			console.log('Trial correct - reward.')
		} 
		else { 
			canvas.sequencepost[1]=canvas.punish;
			canvas.sequencepost[2]=canvas.punish;
			canvas.tsequencepost[2] = TASK.punish;
			console.log('Trial incorrect! - punished.')
		}

		if (FLAGS.current_trial>0){
			if (TRIAL.response[FLAGS.current_trial]==TRIAL.response[FLAGS.current_trial-1]){
				FLAGS.stickyresponse++;
			}
			else {
				FLAGS.stickyresponse=0;
			}
		}
	} 

	// Calculate number of rewards to give
	if (TRIAL.response[FLAGS.current_trial] == TRIAL.correctItem[FLAGS.current_trial] && 
		(FLAGS.current_trial==0 || 
		(TASK.rewardStage==0 && 
			TRIAL.xytfixation[FLAGS.current_trial][2] - TRIAL.xytfixation[FLAGS.current_trial-1][2] < TASK.consecutivehitsITI) || 
		(TASK.rewardStage==1 && 
			TRIAL.xytresponse[FLAGS.current_trial][2] - TRIAL.xytresponse[FLAGS.current_trial-1][2] < TASK.consecutivehitsITI))){
			
			FLAGS.consecutivehits++
			TRIAL.nreward[FLAGS.current_trial] = 1 + Math.floor(FLAGS.consecutivehits / TASK.nconsecutivehitsforbonus)
		if (TRIAL.nreward[FLAGS.current_trial] > TASK.nrewardmax){
			TRIAL.nreward[FLAGS.current_trial] = TASK.nrewardmax
		}
	}
	else {
		if (TRIAL.response[FLAGS.current_trial] == TRIAL.correctItem[FLAGS.current_trial]){
			FLAGS.consecutivehits=1;
			TRIAL.nreward[FLAGS.current_trial] = 1;
		}
		else if (TRIAL.response[FLAGS.current_trial] != TRIAL.correctItem[FLAGS.current_trial]){
			FLAGS.consecutivehits=0;
			TRIAL.nreward[FLAGS.current_trial] = 0;
		}	
	}
	console.log('nhits: ' + FLAGS.consecutivehits + ', nreward: ' + TRIAL.nreward[FLAGS.current_trial])
	
	// Deliver reward or punishment
	frame.shown=[];
	for (var q in canvas.sequencepost){frame.shown[q]=0}; frame.current=0;
	if (canvas.sequencepost[1]==canvas.photoreward && TASK.species == 'marmoset'){
		for (var q = 0; q <= TRIAL.nreward[FLAGS.current_trial]-1; q++){
			frame.shown=[];
			for (var q2 in canvas.sequencepost){frame.shown[q2]=0}; frame.current=0;
			await playSound(2); 
			var p1 = displayTrial(canvas.sequencepost,canvas.tsequencepost)
			if (ble.connected == false){
				await Promise.all([p1])
			}
			else if (ble.connected == true){
				var p2 = writepumpdurationtoBLE(Math.round(TASK.reward*1000))
				await Promise.all([p1, p2])
			}
		}
	} 
	if (canvas.sequencepost[1]==canvas.photoreward && (TASK.species == 'macaque' || TASK.species == "human")){
		for (var q = 0; q <= TRIAL.nreward[FLAGS.current_trial]-1; q++){
			frame.shown=[];
			for (var q2 in canvas.sequencepost){frame.shown[q2]=0}; frame.current=0;
			await playSound(2);
			var p1 = displayTrial(canvas.sequencepost,canvas.tsequencepost)
			var p2 = dispenseReward()
			if (ble.connected == false){
				await Promise.all([p1, p2])
			}
			else if (ble.connected == true){
				var p3 = writepumpdurationtoBLE(Math.round(TASK.reward*1000))
				await Promise.all([p1, p2, p3])
			}
		}
	} // Play pump sound
	if (canvas.sequencepost[1]==canvas.punish){
		if (TASK.species == 'marmoset'){
			playSound(3);
		}
		await displayTrial(canvas.sequencepost,canvas.tsequencepost);
		await dispensePunish();
	}

	// Update trialhistory
	FLAGS.stage=3;
	if (TASK.automator != 0 && FLAGS.savedata == 1){	
		var current_stage = stageHash(TASK); 
		trialhistory.trainingstage.push(current_stage); 

		if (TASK.rewardStage==0 & FLAGS.brokeFixation==0){
			trialhistory.correct.push(1);
		}
		if (TASK.rewardStage==0 & FLAGS.brokeFixation==1){
			trialhistory.correct.push(0);
		}
		if (TASK.rewardStage==1 & TRIAL.response[FLAGS.current_trial] == TRIAL.correctItem[FLAGS.current_trial]){
			trialhistory.correct.push(1);
		}
		else if (TASK.rewardStage==1) {
			trialhistory.correct.push(0);
		}
	}

	// Lazily save the data
	if (FLAGS.savedata == 1 && FLAGS.purge == 0){ 
		writeBehaviortoDropbox(); 			
	}
	
	updateHeadsUpDisplay(); 

	// Check if automator needs to update task
	if (TASK.automator != 0){
		automateTask(automator_data, trialhistory);
		if (FLAGS.need2writeParameters == 1){
			saveParameterstoDropbox(); 
		}
	}

	if (FLAGS.need2loadParameters == 0){
		checkParameterFileStatus()
	}
} // End iteration of main loop 
	//console.log('end of generator for loop');
})(); //async




// }) //spawn
</script>
</body>

<!-- ************ COMMENT SECTION ************ -->
<!-- This code uses generators & promises from ESM6 harmony to implement a state machine.  This is experimental and only supported on modern browsers (see http://caniuse.com/#feat=promises for full support).
The reasons for using this approach are twofold:
(1) Solving the inversion of control with the old way of using async callbacks in javascript (http://blog.getify.com/promises-part-2/)
(2) readability of the code (http://davidwalsh.name/async-generators)
->(1) makes exception handling much easier
->(2) makes the code easier to edit in the future:
		"The main strength of generators is that they provide a single-threaded, synchronous-looking code style, while allowing you to hide the asynchronicity away as an implementation detail. This lets us express in a very natural way what the flow of our program's steps/statements is without simultaneously having to navigate asynchronous syntax and gotchas."
As of 2014.12.01, generators are not supported in safari and not in iOS (even Chrome for iOS is limited to apple webkit).  Could transpile but better to use a native Chrome environment (i.e. android tablet).
// Load audio webkit, see http://middleearmedia.com/controlling-web-audio-api-oscillators/
// var audiocontext = new webkitAudioContext(); // Create audio container with webkit prefix
// In case you're wondering why you can't use the devicePixelRatio to determine the backing store size, the answer is that they aren't guaranteed to match. Despite presenting the same devicePixelRatio value, Chrome and Safari 6 can and do have entirely different approaches for the backing store size (and therefore the webkitBackingStorePixelRatio) on HiDPI devices. The net result is that we can't rely on devicePixelRatio to know how the browser is going to scale images that are written into the canvas.  http://www.html5rocks.com/en/tutorials/canvas/hidpi/
-->
<!-- ************ /COMMENT SECTION ************ -->

</html>